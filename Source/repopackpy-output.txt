================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-08-23T22:36:57.526902

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
ActionPractice.Target.cs
ActionPracticeEditor.Target.cs
ActionPractice\ActionPractice.Build.cs
ActionPractice\ActionPractice.cpp
ActionPractice\ActionPractice.h
ActionPractice\Private\Characters\ActionPracticeCharacter.cpp
ActionPractice\Private\GAS\Abilities\ActionPracticeGameplayAbility.cpp
ActionPractice\Private\GAS\Abilities\AttackAbility.cpp
ActionPractice\Private\GAS\Abilities\BlockAbility.cpp
ActionPractice\Private\GAS\Abilities\JumpAbility.cpp
ActionPractice\Private\GAS\Abilities\RollAbility.cpp
ActionPractice\Private\GAS\Abilities\SprintAbility.cpp
ActionPractice\Private\GAS\Abilities\Tasks\AbilityTask_PlayNormalAttackMontage.cpp
ActionPractice\Private\GAS\ActionPracticeAttributeSet.cpp
ActionPractice\Private\GAS\GameplayTagsSubsystem.cpp
ActionPractice\Private\Games\ActionPracticeGameMode.cpp
ActionPractice\Private\Games\ActionPracticePlayerController.cpp
ActionPractice\Private\Items\Weapon.cpp
ActionPractice\Private\Notifies\AnimNotify_ActionRecoveryEnd.cpp
ActionPractice\Private\Notifies\AnimNotify_EnableComboInput.cpp
ActionPractice\Private\Notifies\AnimNotify_ResetCombo.cpp
ActionPractice\Public\Characters\ActionPracticeCharacter.h
ActionPractice\Public\GAS\Abilities\ActionPracticeGameplayAbility.h
ActionPractice\Public\GAS\Abilities\AttackAbility.h
ActionPractice\Public\GAS\Abilities\BlockAbility.h
ActionPractice\Public\GAS\Abilities\JumpAbility.h
ActionPractice\Public\GAS\Abilities\RollAbility.h
ActionPractice\Public\GAS\Abilities\SprintAbility.h
ActionPractice\Public\GAS\Abilities\Tasks\AbilityTask_PlayNormalAttackMontage.h
ActionPractice\Public\GAS\ActionPracticeAttributeSet.h
ActionPractice\Public\GAS\GameplayTagsDataAsset.h
ActionPractice\Public\GAS\GameplayTagsSubsystem.h
ActionPractice\Public\Games\ActionPracticeGameMode.h
ActionPractice\Public\Games\ActionPracticePlayerController.h
ActionPractice\Public\Items\Weapon.h
ActionPractice\Public\Items\WeaponData.h
ActionPractice\Public\Items\WeaponEnums.h
ActionPractice\Public\Notifies\AnimNotify_ActionRecoveryEnd.h
ActionPractice\Public\Notifies\AnimNotify_EnableComboInput.h
ActionPractice\Public\Notifies\AnimNotify_ResetCombo.h
ActionPractice\Variant_Combat\AI\CombatAIController.cpp
ActionPractice\Variant_Combat\AI\CombatAIController.h
ActionPractice\Variant_Combat\AI\CombatEnemy.cpp
ActionPractice\Variant_Combat\AI\CombatEnemy.h
ActionPractice\Variant_Combat\AI\CombatEnemySpawner.cpp
ActionPractice\Variant_Combat\AI\CombatEnemySpawner.h
ActionPractice\Variant_Combat\AI\CombatStateTreeUtility.cpp
ActionPractice\Variant_Combat\AI\CombatStateTreeUtility.h
ActionPractice\Variant_Combat\AI\EnvQueryContext_Player.cpp
ActionPractice\Variant_Combat\AI\EnvQueryContext_Player.h
ActionPractice\Variant_Combat\AnimNotify_CheckChargedAttack.cpp
ActionPractice\Variant_Combat\AnimNotify_CheckChargedAttack.h
ActionPractice\Variant_Combat\AnimNotify_CheckCombo.cpp
ActionPractice\Variant_Combat\AnimNotify_CheckCombo.h
ActionPractice\Variant_Combat\AnimNotify_DoAttackTrace.cpp
ActionPractice\Variant_Combat\AnimNotify_DoAttackTrace.h
ActionPractice\Variant_Combat\CombatActivatable.cpp
ActionPractice\Variant_Combat\CombatActivatable.h
ActionPractice\Variant_Combat\CombatActivationVolume.cpp
ActionPractice\Variant_Combat\CombatActivationVolume.h
ActionPractice\Variant_Combat\CombatAttacker.cpp
ActionPractice\Variant_Combat\CombatAttacker.h
ActionPractice\Variant_Combat\CombatCharacter.cpp
ActionPractice\Variant_Combat\CombatCharacter.h
ActionPractice\Variant_Combat\CombatCheckpointVolume.cpp
ActionPractice\Variant_Combat\CombatCheckpointVolume.h
ActionPractice\Variant_Combat\CombatDamageable.cpp
ActionPractice\Variant_Combat\CombatDamageable.h
ActionPractice\Variant_Combat\CombatDamageableBox.cpp
ActionPractice\Variant_Combat\CombatDamageableBox.h
ActionPractice\Variant_Combat\CombatDummy.cpp
ActionPractice\Variant_Combat\CombatDummy.h
ActionPractice\Variant_Combat\CombatGameMode.cpp
ActionPractice\Variant_Combat\CombatGameMode.h
ActionPractice\Variant_Combat\CombatLavaFloor.cpp
ActionPractice\Variant_Combat\CombatLavaFloor.h
ActionPractice\Variant_Combat\CombatLifeBar.cpp
ActionPractice\Variant_Combat\CombatLifeBar.h
ActionPractice\Variant_Combat\CombatPlayerController.cpp
ActionPractice\Variant_Combat\CombatPlayerController.h
ActionPractice\Variant_Platforming\AnimNotify_EndDash.cpp
ActionPractice\Variant_Platforming\AnimNotify_EndDash.h
ActionPractice\Variant_Platforming\PlatformingCharacter.cpp
ActionPractice\Variant_Platforming\PlatformingCharacter.h
ActionPractice\Variant_Platforming\PlatformingGameMode.cpp
ActionPractice\Variant_Platforming\PlatformingGameMode.h
ActionPractice\Variant_Platforming\PlatformingPlayerController.cpp
ActionPractice\Variant_Platforming\PlatformingPlayerController.h
ActionPractice\Variant_SideScrolling\AI\SideScrollingAIController.cpp
ActionPractice\Variant_SideScrolling\AI\SideScrollingAIController.h
ActionPractice\Variant_SideScrolling\AI\SideScrollingNPC.cpp
ActionPractice\Variant_SideScrolling\AI\SideScrollingNPC.h
ActionPractice\Variant_SideScrolling\AI\SideScrollingStateTreeUtility.cpp
ActionPractice\Variant_SideScrolling\AI\SideScrollingStateTreeUtility.h
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingJumpPad.cpp
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingJumpPad.h
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingMovingPlatform.cpp
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingMovingPlatform.h
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingPickup.cpp
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingPickup.h
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingSoftPlatform.cpp
ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingSoftPlatform.h
ActionPractice\Variant_SideScrolling\SideScrollingCPP.Build.cs
ActionPractice\Variant_SideScrolling\SideScrollingCameraManager.cpp
ActionPractice\Variant_SideScrolling\SideScrollingCameraManager.h
ActionPractice\Variant_SideScrolling\SideScrollingCharacter.cpp
ActionPractice\Variant_SideScrolling\SideScrollingCharacter.h
ActionPractice\Variant_SideScrolling\SideScrollingGameMode.cpp
ActionPractice\Variant_SideScrolling\SideScrollingGameMode.h
ActionPractice\Variant_SideScrolling\SideScrollingInteractable.cpp
ActionPractice\Variant_SideScrolling\SideScrollingInteractable.h
ActionPractice\Variant_SideScrolling\SideScrollingPlayerController.cpp
ActionPractice\Variant_SideScrolling\SideScrollingPlayerController.h
ActionPractice\Variant_SideScrolling\SideScrollingUI.cpp
ActionPractice\Variant_SideScrolling\SideScrollingUI.h

================================================================
Repository Files
================================================================

================
File: ActionPractice.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class ActionPracticeTarget : TargetRules
{
	public ActionPracticeTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_6;
		ExtraModuleNames.Add("ActionPractice");
	}
}

================
File: ActionPracticeEditor.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class ActionPracticeEditorTarget : TargetRules
{
	public ActionPracticeEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_6;
		ExtraModuleNames.Add("ActionPractice");
	}
}

================
File: ActionPractice\ActionPractice.Build.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class ActionPractice : ModuleRules
{
	public ActionPractice(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] {
			"GameplayAbilities",
			"GameplayTags",
			"GameplayTasks",
			"Core",
			"CoreUObject",
			"Engine",
			"InputCore",
			"EnhancedInput",
			"AIModule",
			"StateTreeModule",
			"GameplayStateTreeModule",
			"UMG"
		});

		PrivateDependencyModuleNames.AddRange(new string[] { });

		PublicIncludePaths.AddRange(new string[] {
			"ActionPractice",
			"ActionPractice/Variant_Platforming",
			"ActionPractice/Variant_Combat",
			"ActionPractice/Variant_Combat/AI",
			"ActionPractice/Variant_SideScrolling",
			"ActionPractice/Variant_SideScrolling/Gameplay",
			"ActionPractice/Variant_SideScrolling/AI"
		});

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });

		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

================
File: ActionPractice\ActionPractice.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.

#include "ActionPractice.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, ActionPractice, "ActionPractice" );

================
File: ActionPractice\ActionPractice.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

================
File: ActionPractice\Private\Characters\ActionPracticeCharacter.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Public/Characters/ActionPracticeCharacter.h"
#include "Engine/LocalPlayer.h"
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "GameFramework/Controller.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"
#include "Interfaces/IHttpResponse.h"
#include "Kismet/GameplayStatics.h"
#include "AbilitySystemComponent.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "GameplayAbilities/Public/Abilities/GameplayAbility.h"
#include "GAS/Abilities/AttackAbility.h"
#include "GAS/GameplayTagsSubsystem.h"

DEFINE_LOG_CATEGORY(LogTemplateCharacter);

// 디버그 로그 활성화/비활성화 (0: 비활성화, 1: 활성화)
#define ENABLE_DEBUG_LOG 0

#if ENABLE_DEBUG_LOG
#define DEBUG_LOG(Format, ...) UE_LOG(LogAbilitySystemComponent, Warning, Format, ##__VA_ARGS__)
#else
#define DEBUG_LOG(Format, ...)
#endif

AActionPracticeCharacter::AActionPracticeCharacter()
{
	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);
		
	// Don't rotate when the controller rotates. Let that just affect the camera.
	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;

	// Configure character movement
	GetCharacterMovement()->bOrientRotationToMovement = true;
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);
	
	GetCharacterMovement()->JumpZVelocity = 500.f;
	GetCharacterMovement()->AirControl = 0.35f;
	GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;
	GetCharacterMovement()->MinAnalogWalkSpeed = 20.f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2000.f;
	GetCharacterMovement()->BrakingDecelerationFalling = 1500.0f;

	// Create a camera boom (pulls in towards the player if there is a collision)
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);
	CameraBoom->TargetArmLength = 400.0f;
	CameraBoom->bUsePawnControlRotation = true;

	// Create a follow camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
	FollowCamera->bUsePawnControlRotation = false;

	// Create Ability System Component
	AbilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystemComponent"));
	AbilitySystemComponent->SetIsReplicated(true);
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);

	// Create Attribute Set
	AttributeSet = CreateDefaultSubobject<UActionPracticeAttributeSet>(TEXT("AttributeSet"));

	// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) 
	// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)
}

void AActionPracticeCharacter::BeginPlay()
{
	Super::BeginPlay();

	// Initialize GAS
	InitializeAbilitySystem();

	EquipWeapon(LoadWeaponClassByName("BP_StraightSword"), false, false);
	EquipWeapon(LoadWeaponClassByName("BP_Shield"), true, false);
}

void AActionPracticeCharacter::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);
	UpdateLockOnCamera();
}

void AActionPracticeCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	// Set up action bindings
	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent)) {
		
		// ===== Basic Input Actions (Direct Function Binding) =====
		if (IA_Move)
		{
			EnhancedInputComponent->BindAction(IA_Move, ETriggerEvent::Triggered, this, &AActionPracticeCharacter::Move);
		}
        
		if (IA_Look)
		{
			EnhancedInputComponent->BindAction(IA_Look, ETriggerEvent::Triggered, this, &AActionPracticeCharacter::Look);
		}

		if(IA_LockOn)
		{
			EnhancedInputComponent->BindAction(IA_LockOn, ETriggerEvent::Started, this, &AActionPracticeCharacter::ToggleLockOn);
		}

		if(IA_WeaponSwitch)
		{
			EnhancedInputComponent->BindAction(IA_WeaponSwitch, ETriggerEvent::Started, this, &AActionPracticeCharacter::WeaponSwitch);
		}

		// ===== GAS Ability Input Actions =====
		// Jump
		if (IA_Jump)
		{
			EnhancedInputComponent->BindAction(IA_Jump, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnJumpInput);
		}
        
		// Sprint (Hold)
		if (IA_Sprint)
		{
			EnhancedInputComponent->BindAction(IA_Sprint, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnSprintInput);
			EnhancedInputComponent->BindAction(IA_Sprint, ETriggerEvent::Completed, this, &AActionPracticeCharacter::OnSprintInputReleased);
		}
        
		// Crouch
		if (IA_Crouch)
		{
			EnhancedInputComponent->BindAction(IA_Crouch, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnCrouchInput);
		}
        
		// Roll
		if (IA_Roll)
		{
			EnhancedInputComponent->BindAction(IA_Roll, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnRollInput);
		}
        
		// Attack
		if (IA_Attack)
		{
			EnhancedInputComponent->BindAction(IA_Attack, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnAttackInput);
		}

		//Hold
		if (IA_ChargeAttack)
		{
			EnhancedInputComponent->BindAction(IA_Block, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnChargeAttackInput);
			EnhancedInputComponent->BindAction(IA_Block, ETriggerEvent::Completed, this, &AActionPracticeCharacter::OnChargeAttackReleased);
		}
		
		// Block (Hold)
		if (IA_Block)
		{
			EnhancedInputComponent->BindAction(IA_Block, ETriggerEvent::Started, this, &AActionPracticeCharacter::OnBlockInput);
			EnhancedInputComponent->BindAction(IA_Block, ETriggerEvent::Completed, this, &AActionPracticeCharacter::OnBlockInputReleased);
		}
    }
}

#pragma region "Move Functions"
void AActionPracticeCharacter::Move(const FInputActionValue& Value)
{
	MovementInputVector = Value.Get<FVector2D>();

	//공격 어빌리티 중단
	if (MovementInputVector.Size() > 0.1f)
	{
		CancelActionForMove();
	}

	bool bIsRecovering = AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag());
	
	if (Controller != nullptr && !bIsRecovering)
	{
		bool bIsSprinting = AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateSprintingTag());
		
		if(!bIsSprinting && bIsLockOn && LockedOnTarget)
		{
			const FVector TargetLocation = LockedOnTarget->GetActorLocation();
			const FVector CharacterLocation = GetActorLocation();
            
			// 타겟을 향한 방향 계산
			FVector DirectionToTarget = TargetLocation - CharacterLocation;
			DirectionToTarget.Z = 0.0f; // 수평 방향만 고려
			DirectionToTarget.Normalize();
            
			// 타겟을 기준으로 한 이동 방향 계산
			const FRotator TargetRotation = DirectionToTarget.Rotation();
			const FVector RightDirection = FRotationMatrix(TargetRotation).GetUnitAxis(EAxis::Y);
			const FVector BackwardDirection = -DirectionToTarget; // 타겟 반대 방향
            
			// Strafe 이동 (좌우 이동)
			AddMovementInput(RightDirection, MovementInputVector.X);
            
			// 전후 이동 (타겟을 기준으로)
			AddMovementInput(BackwardDirection, -MovementInputVector.Y);
            
			// 캐릭터가 타겟을 바라보도록 회전
			SetActorRotation(TargetRotation);
		}

		else //일반적인 회전 이동
		{
			const FRotator Rotation = Controller->GetControlRotation();
			const FRotator YawRotation(0, Rotation.Yaw, 0);
        
			const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
			const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
        
			AddMovementInput(ForwardDirection, MovementInputVector.Y);
			AddMovementInput(RightDirection, MovementInputVector.X);
		}		
	}
}

void AActionPracticeCharacter::CancelActionForMove()
{
	if (!AbilitySystemComponent)
	{
		return;
	}
    
	// Attack 어빌리티가 활성화되어 있는지 확인
	bool bHasActiveAttackAbility = AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateAttackingTag());
	
	if (bHasActiveAttackAbility)
	{
		// State.Recovering 태그가 없으면 어빌리티 캔슬 가능 (ActionRecoveryEnd 이후)
		if (!AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag()))
		{
			// Ability.Attack 태그를 가진 어빌리티 취소
			FGameplayTagContainer CancelTags;
			CancelTags.AddTag(UGameplayTagsSubsystem::GetAbilityAttackNormalTag());
			AbilitySystemComponent->CancelAbilities(&CancelTags);
			UE_LOG(LogTemp, Warning, TEXT("Attack Ability Cancelled by Move Input"));
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("Attack Ability is in Recovering state - cannot cancel"));
		}
	}
}
#pragma endregion

#pragma region "Look Functions"
void AActionPracticeCharacter::Look(const FInputActionValue& Value)
{
	if (Controller == nullptr) return;
	if(bIsLockOn && LockedOnTarget) return;
	
	const FVector2D LookAxisVector = Value.Get<FVector2D>();
	
	AddControllerYawInput(LookAxisVector.X);
	AddControllerPitchInput(LookAxisVector.Y);
}

void AActionPracticeCharacter::ToggleLockOn()
{
	if (bIsLockOn)
	{
		// 락온 해제
		bIsLockOn = false;
		LockedOnTarget = nullptr;
        
		// Spring Arm 설정 복원
		if (CameraBoom)
		{
			//CameraBoom->bUsePawnControlRotation = true;
		}
	}
	else
	{
		// 가장 가까운 적 찾기
		AActor* NearestTarget = FindNearestTarget();
		if (NearestTarget)
		{
			bIsLockOn = true;
			LockedOnTarget = NearestTarget;
            
			// 현재 Spring Arm 설정 저장
			if (CameraBoom)
			{                
				// 락온 시 카메라 설정 (필요시 조정 가능)
				// CameraBoom->TargetArmLength = 500.0f; // 원하는 거리로 조정
				// CameraBoom->SocketOffset = FVector(0.0f, 0.0f, 100.0f); // 원하는 높이로 조정
			}
		}
	}
}

AActor* AActionPracticeCharacter::FindNearestTarget()
{
	TArray<AActor*> FoundTargets;
	UGameplayStatics::GetAllActorsWithTag(GetWorld(), FName("Enemy"), FoundTargets);
    
	AActor* NearestTarget = nullptr;
	float NearestDistance = FLT_MAX;
    
	for (AActor* PotentialTarget : FoundTargets)
	{
		float Distance = FVector::Dist(GetActorLocation(), PotentialTarget->GetActorLocation());
		if (Distance < NearestDistance && Distance < 2000.0f) // 20미터 이내
		{
			NearestDistance = Distance;
			NearestTarget = PotentialTarget;
		}
	}
    
	return NearestTarget;
}

void AActionPracticeCharacter::UpdateLockOnCamera()
{
	if (bIsLockOn && LockedOnTarget && Controller && CameraBoom)
	{
		// 타겟과 캐릭터 위치
		const FVector TargetLocation = LockedOnTarget->GetActorLocation();
		const FVector CharacterLocation = GetActorLocation();
        
		// 캐릭터에서 타겟으로의 방향
		FVector DirectionToTarget = TargetLocation - CharacterLocation;
		DirectionToTarget.Normalize();
        
		// 카메라가 타겟과 캐릭터를 모두 볼 수 있는 각도 계산
		// 캐릭터 뒤에서 타겟을 바라보는 위치
		FVector CameraDirection = -DirectionToTarget;
        
		// 현재 Spring Arm의 길이를 사용하여 카메라 위치 계산
		FVector IdealCameraLocation = CharacterLocation + (CameraDirection * CameraBoom->TargetArmLength);
		IdealCameraLocation.Z += CameraBoom->SocketOffset.Z;
        
		// 카메라가 타겟을 바라보도록 회전 설정
		FRotator LookAtRotation = (TargetLocation - IdealCameraLocation).Rotation();
        
		// 컨트롤러 회전 설정
		Controller->SetControlRotation(LookAtRotation);
        
		// Spring Arm이 캐릭터 회전을 따르지 않도록 설정
		//CameraBoom->bInheritRoll = false;
	}
}
#pragma endregion

#pragma region "Weapon Functions"
void AActionPracticeCharacter::WeaponSwitch()
{
}

void AActionPracticeCharacter::EquipWeapon(TSubclassOf<AWeapon> NewWeaponClass, bool bIsLeftHand, bool bIsTwoHanded)
{
	if (!NewWeaponClass) return;

	if(bIsTwoHanded) UnequipWeapon(!bIsLeftHand);
	UnequipWeapon(bIsLeftHand);
    
	// 새 무기 스폰
	FActorSpawnParameters SpawnParams;
	SpawnParams.Owner = this;
	SpawnParams.Instigator = GetInstigator();
	
	AWeapon* NewWeapon = GetWorld()->SpawnActor<AWeapon>(NewWeaponClass, FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams);
    WeaponEnums type = NewWeapon->GetWeaponType();
	
	if (NewWeapon)
	{
		FString SocketString = bIsLeftHand ? "hand_l" : "hand_r";

		switch (type)
		{
		case WeaponEnums::StraightSword:
			SocketString += "_sword";
			break;

		case WeaponEnums::GreatSword:
			SocketString += "_greatsword";
			break;

		case WeaponEnums::Shield:
			SocketString += "_shield";
			break;
		}
		
		FName SocketName = FName(*SocketString);
		UE_LOG(LogTemp, Warning, TEXT("Equiped Weapon: %s"), *SocketString);
		NewWeapon->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetNotIncludingScale, SocketName);

		if(bIsTwoHanded)
		{
			LeftWeapon = NewWeapon;
			RightWeapon = NewWeapon;
		}
		else if (bIsLeftHand)
		{
			LeftWeapon = NewWeapon;
		}
		
		else
		{
			RightWeapon = NewWeapon;
		}
	}
}

void AActionPracticeCharacter::UnequipWeapon(bool bIsLeftHand)
{
	AWeapon** WeaponToRemove = bIsLeftHand ? &LeftWeapon : &RightWeapon;
    
	if (*WeaponToRemove)
	{
		(*WeaponToRemove)->Destroy();
		*WeaponToRemove = nullptr;
	}
}

TSubclassOf<AWeapon> AActionPracticeCharacter::LoadWeaponClassByName(const FString& WeaponName)
{
	FString BlueprintPath = FString::Printf(TEXT("%s%s.%s_C"), 
										   *WeaponBlueprintBasePath, 
										   *WeaponName, 
										   *WeaponName);
	
	UClass* LoadedClass = LoadClass<AWeapon>(nullptr, *BlueprintPath);
	
	if (LoadedClass && LoadedClass->IsChildOf(AWeapon::StaticClass()))
	{
		return TSubclassOf<AWeapon>(LoadedClass);
	}

	UE_LOG(LogTemp, Warning, TEXT("Failed to load weapon class from path: %s"), *BlueprintPath);
	return nullptr;
}
#pragma endregion

#pragma region "GAS Input Functions"
void AActionPracticeCharacter::OnJumpInput()
{
	GASInputPressed(IA_Jump);
}

void AActionPracticeCharacter::OnSprintInput()
{
	GASInputPressed(IA_Sprint);
}

void AActionPracticeCharacter::OnSprintInputReleased()
{
	GASInputReleased(IA_Sprint);
}

void AActionPracticeCharacter::OnCrouchInput()
{
	GASInputPressed(IA_Crouch);
}

void AActionPracticeCharacter::OnRollInput()
{
	GASInputPressed(IA_Roll);
}

void AActionPracticeCharacter::OnAttackInput()
{
	GASInputPressed(IA_Attack);
}

void AActionPracticeCharacter::OnBlockInput()
{
	GASInputPressed(IA_Block);
}

void AActionPracticeCharacter::OnBlockInputReleased()
{
	GASInputReleased(IA_Block);
}

void AActionPracticeCharacter::OnChargeAttackInput()
{
	
}

void AActionPracticeCharacter::OnChargeAttackReleased()
{
	
}

#pragma endregion

#pragma region "GAS Functions"
UAbilitySystemComponent* AActionPracticeCharacter::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}

void AActionPracticeCharacter::InitializeAbilitySystem()
{
	if (AbilitySystemComponent)
	{
		// Initialize the Ability System Component on the owning actor (this character)
		AbilitySystemComponent->InitAbilityActorInfo(this, this);
		
		// Set up the Attribute Set
		if (AttributeSet)
		{
			// Attributes are automatically initialized in the AttributeSet constructor
			// Additional setup can be done here if needed
		}
		
		// Grant startup abilities
		for (const auto& StartAbility : StartAbilities)
		{
			GiveAbility(StartAbility);
		}

		for (const auto& StartInputAbility : StartInputAbilities)
		{
			GiveAbility(StartInputAbility.Value);
		}

		FGameplayEffectContextHandle EffectContext = AbilitySystemComponent->MakeEffectContext();
		EffectContext.AddSourceObject(this);
		
		for (const auto& StartEffect : StartEffects)
		{
			if (StartEffect)
			{
				FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent->MakeOutgoingSpec(StartEffect, 1, EffectContext);
				if (SpecHandle.IsValid())
				{
					AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
				}
			}
		}
	}
}

void AActionPracticeCharacter::GiveAbility(TSubclassOf<UGameplayAbility> AbilityClass)
{
	if (AbilitySystemComponent && AbilityClass)
	{
		FGameplayAbilitySpec AbilitySpec(AbilityClass, 1, INDEX_NONE, this);
		AbilitySystemComponent->GiveAbility(AbilitySpec);
	}
}

void AActionPracticeCharacter::GASInputPressed(const UInputAction* InputAction)
{
	if (!AbilitySystemComponent || !InputAction) return;
	
	TSubclassOf<UGameplayAbility>* AbilityClass = StartInputAbilities.Find(InputAction);
	FGameplayAbilitySpec* Spec = AbilitySystemComponent->FindAbilitySpecFromClass(*AbilityClass);
	
	if (Spec)
	{
		Spec->InputPressed = true;
		
		if (Spec->IsActive())
		{
			AbilitySystemComponent->AbilitySpecInputPressed(*Spec);
		}

		else
		{
			AbilitySystemComponent->TryActivateAbility(Spec->Handle);
		}
	}
}

void AActionPracticeCharacter::GASInputReleased(const UInputAction* InputAction)
{
	if (!AbilitySystemComponent || !InputAction) return;
	
	TSubclassOf<UGameplayAbility>* AbilityClass = StartInputAbilities.Find(InputAction);
	FGameplayAbilitySpec* Spec = AbilitySystemComponent->FindAbilitySpecFromClass(*AbilityClass);

	if (Spec)
	{
		Spec->InputPressed = false;
		
		if (Spec->IsActive())
		{
			AbilitySystemComponent->AbilitySpecInputReleased(*Spec);
		}
	}
}
#pragma endregion

================
File: ActionPractice\Private\Games\ActionPracticeGameMode.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Public/Games/ActionPracticeGameMode.h"

AActionPracticeGameMode::AActionPracticeGameMode()
{
	// stub
}

================
File: ActionPractice\Private\Games\ActionPracticePlayerController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Public/Games/ActionPracticePlayerController.h"
#include "EnhancedInputSubsystems.h"
#include "Engine/LocalPlayer.h"
#include "InputMappingContext.h"

void AActionPracticePlayerController::SetupInputComponent()
{
	Super::SetupInputComponent();

	// Add Input Mapping Contexts
	if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))
	{
		for (UInputMappingContext* CurrentContext : DefaultMappingContexts)
		{
			Subsystem->AddMappingContext(CurrentContext, 0);
		}
	}
}

================
File: ActionPractice\Private\GAS\ActionPracticeAttributeSet.cpp
================
#include "GAS/ActionPracticeAttributeSet.h"
#include "GameplayEffect.h"
#include "GameplayEffectExtension.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/Character.h"
#include "GameFramework/CharacterMovementComponent.h"

UActionPracticeAttributeSet::UActionPracticeAttributeSet()
{
	// Set default values (엘든링 초기 스텟)
	InitHealth(100.0f);
	InitMaxHealth(100.0f);
	InitStamina(100.0f);
	InitMaxStamina(100.0f);
	InitStaminaRegenRate(10.0f);
	InitDefense(10.0f);
	InitStrength(10.0f);
	InitDexterity(10.0f);
	InitPhysicalAttackPower(50.0f);
	InitMovementSpeed(600.0f);
}

void UActionPracticeAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, Health, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, Stamina, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, StaminaRegenRate, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, Defense, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, Strength, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, Dexterity, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, PhysicalAttackPower, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UActionPracticeAttributeSet, MovementSpeed, COND_None, REPNOTIFY_Always);
}

void UActionPracticeAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);

	// Clamp values to prevent negative or invalid values
	if (Attribute == GetMaxHealthAttribute())
	{
		NewValue = FMath::Max(NewValue, 1.0f);
	}
	else if (Attribute == GetHealthAttribute())
	{
		NewValue = FMath::Clamp(NewValue, 0.0f, GetMaxHealth());
	}
	else if (Attribute == GetMaxStaminaAttribute())
	{
		NewValue = FMath::Max(NewValue, 0.0f);
	}
	else if (Attribute == GetStaminaAttribute())
	{
		NewValue = FMath::Clamp(NewValue, 0.0f, GetMaxStamina());
	}
	else if (Attribute == GetStaminaRegenRateAttribute())
	{
		NewValue = FMath::Max(NewValue, 0.0f);
	}
	else if (Attribute == GetDefenseAttribute())
	{
		NewValue = FMath::Max(NewValue, 0.0f);
	}
	else if (Attribute == GetStrengthAttribute())
	{
		NewValue = FMath::Max(NewValue, 1.0f); // 최소 1
	}
	else if (Attribute == GetDexterityAttribute())
	{
		NewValue = FMath::Max(NewValue, 1.0f); // 최소 1
	}
	else if (Attribute == GetMovementSpeedAttribute())
	{
		NewValue = FMath::Max(NewValue, 0.0f);
	}
}

void UActionPracticeAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
	Super::PostGameplayEffectExecute(Data);

	FGameplayEffectContextHandle Context = Data.EffectSpec.GetContext();
	UAbilitySystemComponent* Source = Context.GetOriginalInstigatorAbilitySystemComponent();
	const FGameplayTagContainer& SourceTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();

	// Get the Target actor, which should be our owner
	AActor* TargetActor = nullptr;
	AController* TargetController = nullptr;
	ACharacter* TargetCharacter = nullptr;
	if (Data.Target.AbilityActorInfo.IsValid() && Data.Target.AbilityActorInfo->AvatarActor.IsValid())
	{
		TargetActor = Data.Target.AbilityActorInfo->AvatarActor.Get();
		TargetController = Data.Target.AbilityActorInfo->PlayerController.Get();
		TargetCharacter = Cast<ACharacter>(TargetActor);
	}

	// Handle incoming damage
	if (Data.EvaluatedData.Attribute == GetIncomingDamageAttribute())
	{
		// Get the Source actor
		AActor* SourceActor = nullptr;
		AController* SourceController = nullptr;
		if (Source && Source->AbilityActorInfo.IsValid() && Source->AbilityActorInfo->AvatarActor.IsValid())
		{
			SourceActor = Source->AbilityActorInfo->AvatarActor.Get();
			SourceController = Source->AbilityActorInfo->PlayerController.Get();
		}

		// Store a local copy of the amount of damage done and clear the damage attribute
		const float LocalIncomingDamage = GetIncomingDamage();
		SetIncomingDamage(0.f);

		if (LocalIncomingDamage > 0)
		{
			// Apply defense calculation (엘든링 스타일 방어력 계산)
			const float DefenseReduction = GetDefense() / (GetDefense() + 100.0f);
			const float FinalDamage = LocalIncomingDamage * (1.0f - DefenseReduction);
			
			// Apply the health change
			const float OldHealth = GetHealth();
			SetHealth(FMath::Clamp(OldHealth - FinalDamage, 0.0f, GetMaxHealth()));

			// Handle death
			if (GetHealth() <= 0.0f)
			{
				// TODO: Implement death logic
			}
		}
	}
	// Handle incoming healing
	else if (Data.EvaluatedData.Attribute == GetIncomingHealingAttribute())
	{
		const float LocalIncomingHealing = GetIncomingHealing();
		SetIncomingHealing(0.f);

		if (LocalIncomingHealing > 0)
		{
			const float OldHealth = GetHealth();
			SetHealth(FMath::Clamp(OldHealth + LocalIncomingHealing, 0.0f, GetMaxHealth()));
		}
	}
	// Handle direct health changes
	else if (Data.EvaluatedData.Attribute == GetHealthAttribute())
	{
		SetHealth(FMath::Clamp(GetHealth(), 0.0f, GetMaxHealth()));
	}
	// Handle stamina changes
	else if (Data.EvaluatedData.Attribute == GetStaminaAttribute())
	{
		SetStamina(FMath::Clamp(GetStamina(), 0.0f, GetMaxStamina()));
	}
	// Handle max health changes
	else if (Data.EvaluatedData.Attribute == GetMaxHealthAttribute())
	{
		AdjustAttributeForMaxChange(Health, MaxHealth, GetMaxHealth(), GetHealthAttribute());
	}
	// Handle max stamina changes
	else if (Data.EvaluatedData.Attribute == GetMaxStaminaAttribute())
	{
		AdjustAttributeForMaxChange(Stamina, MaxStamina, GetMaxStamina(), GetStaminaAttribute());
	}
	// Handle stat changes that affect secondary attributes
	else if (Data.EvaluatedData.Attribute == GetStrengthAttribute() || 
			 Data.EvaluatedData.Attribute == GetDexterityAttribute())
	{
		CalculateSecondaryAttributes();
	}
	// Handle movement speed changes
	else if (Data.EvaluatedData.Attribute == GetMovementSpeedAttribute())
	{
		if (TargetCharacter && TargetCharacter->GetCharacterMovement())
		{
			TargetCharacter->GetCharacterMovement()->MaxWalkSpeed = GetMovementSpeed();
		}
	}
}

void UActionPracticeAttributeSet::CalculateSecondaryAttributes()
{
	// Calculate Physical Attack Power based on Strength and Dexterity
	// 기본 공격력 + 스텟 보너스
	const float BaseAttackPower = 50.0f;
	const float StrengthBonus = GetStrength() * 0.8f;
	const float DexterityBonus = GetDexterity() * 0.6f;
	
	SetPhysicalAttackPower(BaseAttackPower + StrengthBonus + DexterityBonus);
}

float UActionPracticeAttributeSet::GetHealthPercent() const
{
	return GetMaxHealth() > 0.0f ? GetHealth() / GetMaxHealth() : 0.0f;
}

float UActionPracticeAttributeSet::GetStaminaPercent() const
{
	return GetMaxStamina() > 0.0f ? GetStamina() / GetMaxStamina() : 0.0f;
}

float UActionPracticeAttributeSet::CalculateWeaponDamageBonus(float StrengthScaling, float DexterityScaling) const
{
	// 엘든링 스타일 무기 스케일링 계산
	const float StrengthBonus = GetStrength() * StrengthScaling * 0.01f; // 스케일링을 퍼센트로 계산
	const float DexterityBonus = GetDexterity() * DexterityScaling * 0.01f;
	
	return StrengthBonus + DexterityBonus;
}

// Rep Notify Functions
void UActionPracticeAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, Health, OldHealth);
}

void UActionPracticeAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, MaxHealth, OldMaxHealth);
}

void UActionPracticeAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, Stamina, OldStamina);
}

void UActionPracticeAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, MaxStamina, OldMaxStamina);
}

void UActionPracticeAttributeSet::OnRep_StaminaRegenRate(const FGameplayAttributeData& OldStaminaRegenRate)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, StaminaRegenRate, OldStaminaRegenRate);
}

void UActionPracticeAttributeSet::OnRep_Defense(const FGameplayAttributeData& OldDefense)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, Defense, OldDefense);
}

void UActionPracticeAttributeSet::OnRep_Strength(const FGameplayAttributeData& OldStrength)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, Strength, OldStrength);
}

void UActionPracticeAttributeSet::OnRep_Dexterity(const FGameplayAttributeData& OldDexterity)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, Dexterity, OldDexterity);
}

void UActionPracticeAttributeSet::OnRep_PhysicalAttackPower(const FGameplayAttributeData& OldPhysicalAttackPower)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, PhysicalAttackPower, OldPhysicalAttackPower);
}

void UActionPracticeAttributeSet::OnRep_MovementSpeed(const FGameplayAttributeData& OldMovementSpeed)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UActionPracticeAttributeSet, MovementSpeed, OldMovementSpeed);
}

void UActionPracticeAttributeSet::AdjustAttributeForMaxChange(FGameplayAttributeData& AffectedAttribute, const FGameplayAttributeData& MaxAttribute, float NewMaxValue, const FGameplayAttribute& AffectedAttributeProperty)
{
	UAbilitySystemComponent* AbilityComp = GetOwningAbilitySystemComponent();
	const float CurrentMaxValue = MaxAttribute.GetCurrentValue();
	if (!FMath::IsNearlyEqual(CurrentMaxValue, NewMaxValue) && AbilityComp)
	{
		// Change current value to maintain the current Val / Max percent
		const float CurrentValue = AffectedAttribute.GetCurrentValue();
		float NewDelta = (CurrentMaxValue > 0.f) ? (CurrentValue * NewMaxValue / CurrentMaxValue) - CurrentValue : NewMaxValue;

		AbilityComp->ApplyModToAttributeUnsafe(AffectedAttributeProperty, EGameplayModOp::Additive, NewDelta);
	}
}

================
File: ActionPractice\Private\GAS\GameplayTagsSubsystem.cpp
================
#include "GAS/GameplayTagsSubsystem.h"
#include "GAS/GameplayTagsDataAsset.h"
#include "Engine/World.h"
#include "Engine/Engine.h"

void UGameplayTagsSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	
	// 데이터 에셋 로드 (에디터에서 설정한 데이터 에셋 경로)
	// TODO: 프로젝트 설정 또는 기본 경로에서 데이터 에셋 로드
	const FString DataAssetPath = TEXT("/Game/GAS/DA_GameplayTags");
	GameplayTagsDataAsset = LoadObject<UGameplayTagsDataAsset>(nullptr, *DataAssetPath);
	
	if (!GameplayTagsDataAsset)
	{
		UE_LOG(LogTemp, Warning, TEXT("GameplayTagsDataAsset could not be loaded from path: %s"), *DataAssetPath);
	}
}

UGameplayTagsSubsystem* UGameplayTagsSubsystem::Get()
{
	if (GEngine)
	{
		for (const FWorldContext& WorldContext : GEngine->GetWorldContexts())
		{
			if (WorldContext.World() && WorldContext.WorldType != EWorldType::EditorPreview)
			{
				if (UGameInstance* GameInstance = WorldContext.World()->GetGameInstance())
				{
					return GameInstance->GetSubsystem<UGameplayTagsSubsystem>();
				}
			}
		}
	}
	
	return nullptr;
}

#pragma region "Static Accessor Functions"

// Ability Tags
const FGameplayTag& UGameplayTagsSubsystem::GetAbilityAttackNormalTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilityAttackNormalTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityAttackChargeTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilityAttackChargeTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityRollTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilityRollTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilitySprintTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilitySprintTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityJumpTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilityJumpTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityBlockTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetAbilityBlockTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

// State Tags
const FGameplayTag& UGameplayTagsSubsystem::GetStateAttackingTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateAttackingTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateBlockingTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateBlockingTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateRecoveringTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateRecoveringTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateStunnedTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateStunnedTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateInvincibleTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateInvincibleTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateJumpingTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateJumpingTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateSprintingTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetStateSprintingTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

// Event Tags
const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyEnableComboInputTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetEventNotifyEnableComboInputTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyActionRecoveryEndTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetEventNotifyActionRecoveryEndTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyResetComboTag()
{
	if (UGameplayTagsSubsystem* Subsystem = Get())
	{
		return Subsystem->GetEventNotifyResetComboTagInternal();
	}
	return FGameplayTag::EmptyTag;
}

#pragma endregion

#pragma region "Internal Tag Functions"

// Ability Tags
const FGameplayTag& UGameplayTagsSubsystem::GetAbilityAttackNormalTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Attack_Normal;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityAttackChargeTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Attack_Charge;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityRollTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Roll;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilitySprintTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Sprint;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityJumpTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Jump;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetAbilityBlockTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Ability_Block;
	}
	return FGameplayTag::EmptyTag;
}

// State Tags
const FGameplayTag& UGameplayTagsSubsystem::GetStateAttackingTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Attacking;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateBlockingTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Blocking;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateRecoveringTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Recovering;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateStunnedTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Stunned;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateInvincibleTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Invincible;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateJumpingTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Jumping;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetStateSprintingTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->State_Sprinting;
	}
	return FGameplayTag::EmptyTag;
}

// Event Tags
const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyEnableComboInputTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Event_Notify_EnableComboInput;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyActionRecoveryEndTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Event_Notify_ActionRecoveryEnd;
	}
	return FGameplayTag::EmptyTag;
}

const FGameplayTag& UGameplayTagsSubsystem::GetEventNotifyResetComboTagInternal() const
{
	if (GameplayTagsDataAsset)
	{
		return GameplayTagsDataAsset->Event_Notify_ResetCombo;
	}
	return FGameplayTag::EmptyTag;
}

#pragma endregion

================
File: ActionPractice\Private\GAS\Abilities\ActionPracticeGameplayAbility.cpp
================
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "AbilitySystemComponent.h"
#include "GameplayEffect.h"

UActionPracticeGameplayAbility::UActionPracticeGameplayAbility()
{
	// 기본 설정
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	
	// 기본 태그 설정은 상속 클래스에서 직접 처리
}

void UActionPracticeGameplayAbility::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec)
{
	Super::OnGiveAbility(ActorInfo, Spec);

	// 어빌리티가 부여될 때의 추가 설정이 필요하면 여기에 구현
}

bool UActionPracticeGameplayAbility::CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, OUT FGameplayTagContainer* OptionalRelevantTags) const
{
	if (!Super::CanActivateAbility(Handle, ActorInfo, SourceTags, TargetTags, OptionalRelevantTags))
	{
		return false;
	}

	// 스태미나 체크
	if (!CheckStaminaCost())
	{
		return false;
	}

	return true;
}

bool UActionPracticeGameplayAbility::CheckStaminaCost() const
{
	if (StaminaCost <= 0.0f)
	{
		return true;
	}

	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	if (AttributeSet)
	{
		return AttributeSet->GetStamina() >= StaminaCost;
	}

	return false;
}

bool UActionPracticeGameplayAbility::ConsumeStamina()
{
	if (StaminaCost <= 0.0f)
	{
		return true;
	}

	UAbilitySystemComponent* ASC = GetAbilitySystemComponentFromActorInfo();
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();

	if (ASC && AttributeSet)
	{
		// 스태미나 소모 GameplayEffect를 적용
		// 여기서는 직접 속성을 수정하는 방식을 사용
		const float CurrentStamina = AttributeSet->GetStamina();
		const float NewStamina = FMath::Max(0.0f, CurrentStamina - StaminaCost);
		
		// 속성 직접 설정 (실제 프로젝트에서는 GameplayEffect 사용 권장)
		const_cast<UActionPracticeAttributeSet*>(AttributeSet)->SetStamina(NewStamina);
		
		return true;
	}

	return false;
}

void UActionPracticeGameplayAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 스태미나 소모
	if (!ConsumeStamina())
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

void UActionPracticeGameplayAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

AActionPracticeCharacter* UActionPracticeGameplayAbility::GetActionPracticeCharacterFromActorInfo() const
{
	return Cast<AActionPracticeCharacter>(GetActorInfo().AvatarActor.Get());
}

UActionPracticeAttributeSet* UActionPracticeGameplayAbility::GetActionPracticeAttributeSetFromActorInfo() const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (Character)
	{
		return Character->GetAttributeSet();
	}
	return nullptr;
}

================
File: ActionPractice\Private\GAS\Abilities\AttackAbility.cpp
================
#include "GAS/Abilities/AttackAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "Items/Weapon.h"
#include "GAS/Abilities/Tasks/AbilityTask_PlayNormalAttackMontage.h"
#include "AbilitySystemComponent.h"
#include "Animation/AnimMontage.h"
#include "GameplayTagContainer.h"

#define ENABLE_DEBUG_LOG 0

#if ENABLE_DEBUG_LOG
    #define DEBUG_LOG(Format, ...) UE_LOG(LogAbilitySystemComponent, Warning, Format, ##__VA_ARGS__)
#else
    #define DEBUG_LOG(Format, ...)
#endif

UAttackAbility::UAttackAbility()
{
    StaminaCost = 15.0f;
}

void UAttackAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        DEBUG_LOG(TEXT("Cannot Commit Ability"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }

    // 무기 정보 가져오기
    AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
    if (!Character)
    {
        DEBUG_LOG(TEXT("No Character"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    AWeapon* Weapon = Character->GetRightWeapon();
    if (!Weapon)
    {
        DEBUG_LOG(TEXT("No Weapon"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    FGameplayTag MainTag = this->AbilityTags.First();
    if (!MainTag.IsValid())
    {
        DEBUG_LOG(TEXT("No Ability MainTag"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    WeaponAttackData = Weapon->GetWeaponAttackDataByTag(MainTag);
    if (WeaponAttackData->AttackMontages.IsEmpty() || !WeaponAttackData->AttackMontages[0])
    {
        DEBUG_LOG(TEXT("No Montage Data - ListEmpty: %d, FirstEmpty: %d"), WeaponAttackData->AttackMontages.IsEmpty(), !WeaponAttackData->AttackMontages[0]);
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }
    
    // 몽타주 배열과 콤보 데이터 배열 크기 일치 검증
    if (WeaponAttackData->AttackMontages.Num() != WeaponAttackData->ComboAttackData.Num())
    {
        UE_LOG(LogAbilitySystemComponent, Error, TEXT("AttackMontages and ComboAttackData array size mismatch!"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    // 스태미나 소모
    if (!ConsumeStamina())
    {
        DEBUG_LOG(TEXT("No Stamina"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    // 커스텀 태스크 생성 - 몽타주 배열 전달
    NormalAttackTask = UAbilityTask_PlayNormalAttackMontage::CreatePlayNormalAttackMontageProxy(
        this,
        NAME_None,
        WeaponAttackData->AttackMontages,
        1.0f,
        NAME_None,
        1.0f
    );

    if (NormalAttackTask)
    {
        // 태스크 세팅 - 몽타주 배열 크기로 설정
        NormalAttackTask->MaxComboCount = WeaponAttackData->AttackMontages.Num();
        NormalAttackTask->ComboCounter = 0;
        
        // 델리게이트 바인딩
        NormalAttackTask->OnCompleted.AddDynamic(this, &UAttackAbility::OnTaskCompleted);
        NormalAttackTask->OnBlendOut.AddDynamic(this, &UAttackAbility::OnTaskCompleted);
        NormalAttackTask->OnInterrupted.AddDynamic(this, &UAttackAbility::OnTaskInterrupted);
        NormalAttackTask->OnCancelled.AddDynamic(this, &UAttackAbility::OnTaskInterrupted);
        NormalAttackTask->OnComboPerformed.AddDynamic(this, &UAttackAbility::OnComboPerformed);

        // 태스크 활성화
        NormalAttackTask->ReadyForActivation();
    }
    else
    {
        DEBUG_LOG(TEXT("No NormalAttackTask"));
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
    }
}

void UAttackAbility::InputPressed(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo)
{
    if (NormalAttackTask)
    {
        // 콤보 진행 전 스태미나 체크
        if (NormalAttackTask->bCanComboSave || NormalAttackTask->bIsInCancellableRecovery)
        {
            if (!ConsumeStamina())
            {
                return;
            }
        }

        // 태스크에 입력 처리 위임
        NormalAttackTask->CheckComboInputPreseed();
    }
}

void UAttackAbility::OnTaskCompleted()
{
    EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
    DEBUG_LOG(TEXT("Task Completed - EndAbility"));
}

void UAttackAbility::OnTaskInterrupted()
{
    EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
    DEBUG_LOG(TEXT("Task Interrupted - EndAbility"));
}

void UAttackAbility::OnComboPerformed()
{
    // 콤보 실행시 필요한 추가 처리
    // 예: VFX, SFX, 카메라 효과 등
}

void UAttackAbility::CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility)
{
    DEBUG_LOG(TEXT("AttackAbility Cancelled"));
    
    // 태스크가 활성화되어 있다면 외부 취소 호출
    if (NormalAttackTask && NormalAttackTask->IsActive())
    {
        DEBUG_LOG(TEXT("Cancelling NormalAttackTask"));
        NormalAttackTask->ExternalCancel();
    }
    
    Super::CancelAbility(Handle, ActorInfo, ActivationInfo, bReplicateCancelAbility);
}

void UAttackAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
    DEBUG_LOG(TEXT("EndAbility %d"), bWasCancelled);
    if (IsEndAbilityValid(Handle, ActorInfo))
    {
        if (NormalAttackTask)
        {
            NormalAttackTask->bStopMontageWhenAbilityCancelled = bWasCancelled;
        }

        Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
    }
}

================
File: ActionPractice\Private\GAS\Abilities\BlockAbility.cpp
================
#include "GAS/Abilities/BlockAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "Items/Weapon.h"
#include "AbilitySystemComponent.h"
#include "Animation/AnimMontage.h"
#include "Animation/AnimInstance.h"
#include "Components/SkeletalMeshComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Engine/World.h"
#include "TimerManager.h"

UBlockAbility::UBlockAbility()
{
	// GameplayTag는 Blueprint에서 설정
	
	// 초기 스태미나 비용 (방어 시작 시)
	StaminaCost = 5.0f;
	
	// 기본값 설정
	StaminaDrainPerSecond = 8.0f;
	DamageReductionMultiplier = 0.2f; // 80% 데미지 감소
	StaminaDamageReduction = 0.5f;
	MovementSpeedMultiplier = 0.3f;
	BlockAngle = 120.0f;
	ParryWindow = 0.3f;
	GuardBreakThreshold = 50.0f;
}

void UBlockAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 방어 시작
	StartBlocking();
}

void UBlockAbility::InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo)
{
	Super::InputReleased(Handle, ActorInfo, ActivationInfo);
}

void UBlockAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	// 방어 종료
	StopBlocking();

	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void UBlockAbility::StartBlocking()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
		return;
	}

	bIsBlocking = true;
	BlockStartTime = GetWorld()->GetTimeSeconds();

	// 초기 스태미나 소모
	ConsumeStamina();

	// 이동 속도 감소
	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (MovementComp)
	{
		float BaseSpeed = MovementComp->MaxWalkSpeed / MovementSpeedMultiplier;
		MovementComp->MaxWalkSpeed = BaseSpeed * MovementSpeedMultiplier;
	}

	// 방어 시작 몽타주 재생
	if (BlockStartMontage)
	{
		UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
		if (AnimInstance)
		{
			// 몽타주 종료 델리게이트 바인딩
			if (!MontageEndedDelegate.IsBound())
			{
				MontageEndedDelegate = FOnMontageEnded::CreateUObject(this, &UBlockAbility::OnMontageEnded);
				AnimInstance->Montage_SetEndDelegate(MontageEndedDelegate, BlockStartMontage);
			}
			
			AnimInstance->Montage_Play(BlockStartMontage);
		}
	}

	// 스태미나 지속 소모 타이머 시작
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(
			StaminaDrainTimer,
			this,
			&UBlockAbility::DrainStamina,
			1.0f / StaminaDrainPerSecond,
			true
		);
	}

	UE_LOG(LogTemp, Warning, TEXT("Block started"));
}

void UBlockAbility::HandleBlocking(float DeltaTime)
{
	// 지속적인 방어 처리 (필요시 구현)
}

void UBlockAbility::StopBlocking()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	bIsBlocking = false;

	// 스태미나 소모 타이머 정지
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(StaminaDrainTimer);
	}

	// 이동 속도 복구
	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (MovementComp)
	{
		MovementComp->MaxWalkSpeed = MovementComp->MaxWalkSpeed / MovementSpeedMultiplier;
	}

	// 방어 종료 몽타주 재생
	if (BlockEndMontage)
	{
		UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
		if (AnimInstance)
		{
			AnimInstance->Montage_Play(BlockEndMontage);
		}
	}

	UE_LOG(LogTemp, Warning, TEXT("Block ended"));
}

void UBlockAbility::HandleBlockSuccess(float IncomingDamage, AActor* DamageSource)
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	
	if (!Character || !AttributeSet)
	{
		return;
	}

	// 패리 윈도우 체크
	if (IsInParryWindow())
	{
		HandleParrySuccess(DamageSource);
		return;
	}

	// 방어 효율성 계산
	float BlockEffectiveness = CalculateBlockEffectiveness();
	
	// 감소된 데미지 계산
	float ReducedDamage = IncomingDamage * DamageReductionMultiplier * (1.0f - BlockEffectiveness);
	
	// 스태미나 데미지 계산
	float StaminaDamage = IncomingDamage * StaminaDamageReduction;
	
	// 방어구 및 무기 고려
	AWeapon* Shield = Character->GetLeftWeapon();
	if (Shield && Shield->GetWeaponType() == WeaponEnums::Shield)
	{
		//ReducedDamage *= (1.0f - Shield->GetPhysicalReduction() / 100.0f);
		//StaminaDamage *= (1.0f - Shield->GetStaminaDamage() / 100.0f);
	}

	// 스태미나 소모
	float CurrentStamina = AttributeSet->GetStamina();
	float NewStamina = FMath::Max(0.0f, CurrentStamina - StaminaDamage);
	const_cast<UActionPracticeAttributeSet*>(AttributeSet)->SetStamina(NewStamina);

	// 가드 브레이크 체크
	if (StaminaDamage >= GuardBreakThreshold || NewStamina <= 0.0f)
	{
		HandleGuardBreak();
		return;
	}

	// 남은 데미지 적용
	if (ReducedDamage > 0.0f)
	{
		float CurrentHealth = AttributeSet->GetHealth();
		float NewHealth = FMath::Max(0.0f, CurrentHealth - ReducedDamage);
		const_cast<UActionPracticeAttributeSet*>(AttributeSet)->SetHealth(NewHealth);
	}

	UE_LOG(LogTemp, Warning, TEXT("Blocked attack! Reduced damage: %f, Stamina damage: %f"), ReducedDamage, StaminaDamage);
}

void UBlockAbility::HandleParrySuccess(AActor* DamageSource)
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	// 패리 성공 몽타주 재생
	if (BlockSuccessMontage)
	{
		UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
		if (AnimInstance)
		{
			AnimInstance->Montage_Play(BlockSuccessMontage);
		}
	}

	// 패리 성공 시 상대방을 스턴시키거나 카운터 어택 기회 제공
	// TODO: 상대방에게 스턴 효과 적용

	UE_LOG(LogTemp, Warning, TEXT("Parry successful!"));
}

void UBlockAbility::HandleGuardBreak()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	// 가드 브레이크 몽타주 재생
	if (BlockFailMontage)
	{
		UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
		if (AnimInstance)
		{
			AnimInstance->Montage_Play(BlockFailMontage);
		}
	}

	// 방어 강제 종료
	EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);

	// TODO: 스턴 효과 적용

	UE_LOG(LogTemp, Warning, TEXT("Guard broken!"));
}

bool UBlockAbility::CanBlockFromDirection(const FVector& DamageDirection) const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return false;
	}

	FVector CharacterForward = Character->GetActorForwardVector();
	FVector NormalizedDamageDir = DamageDirection.GetSafeNormal();

	float DotProduct = FVector::DotProduct(CharacterForward, -NormalizedDamageDir);
	float AngleInDegrees = FMath::RadiansToDegrees(FMath::Acos(DotProduct));

	return AngleInDegrees <= (BlockAngle * 0.5f);
}

float UBlockAbility::CalculateBlockEffectiveness() const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	
	if (!Character || !AttributeSet)
	{
		return 0.0f;
	}

	// 기본 방어 효율성
	float Effectiveness = 0.5f;

	// 방패가 있으면 효율성 증가
	AWeapon* Shield = Character->GetLeftWeapon();
	if (Shield && Shield->GetWeaponType() == WeaponEnums::Shield)
	{
		Effectiveness += 0.3f;
		
		// 방패의 방어 스탯 고려
		//Effectiveness += (Shield->GetPhysicalReduction() / 100.0f) * 0.2f;
	}

	// 근력에 따른 방어 효율성 (방패 사용 시)
	if (Shield)
	{
		float StrengthBonus = (AttributeSet->GetStrength() / 100.0f) * 0.2f;
		Effectiveness += StrengthBonus;
	}

	return FMath::Clamp(Effectiveness, 0.0f, 1.0f);
}

bool UBlockAbility::IsInParryWindow() const
{
	if (!bIsBlocking)
	{
		return false;
	}

	float CurrentTime = GetWorld()->GetTimeSeconds();
	return (CurrentTime - BlockStartTime) <= ParryWindow;
}

void UBlockAbility::DrainStamina()
{
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	if (AttributeSet)
	{
		float CurrentStamina = AttributeSet->GetStamina();
		float NewStamina = FMath::Max(0.0f, CurrentStamina - 1.0f);
		const_cast<UActionPracticeAttributeSet*>(AttributeSet)->SetStamina(NewStamina);

		// 스태미나가 부족하면 방어 종료
		if (NewStamina <= 0.0f)
		{
			EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
		}
	}
}

void UBlockAbility::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	if (Montage == BlockStartMontage)
	{
		// 방어 유지 몽타주로 전환 (있는 경우)
		if (BlockIdleMontage && bIsBlocking)
		{
			AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
			if (Character)
			{
				UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
				if (AnimInstance)
				{
					AnimInstance->Montage_Play(BlockIdleMontage);
				}
			}
		}
	}
}

================
File: ActionPractice\Private\GAS\Abilities\JumpAbility.cpp
================
#include "GAS/Abilities/JumpAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Engine/World.h"
#include "TimerManager.h"

UJumpAbility::UJumpAbility()
{
	// GameplayTag는 Blueprint에서 설정
	
	// 스태미나 비용
	StaminaCost = 10.0f;
	
	// 기본값 설정
	JumpZVelocity = 600.0f;
	bAllowDoubleJump = false;
	DoubleJumpMultiplier = 0.8f;
	MaxJumpCount = 1;

	// 즉시 실행되는 어빌리티
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerExecution;
}

bool UJumpAbility::CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, OUT FGameplayTagContainer* OptionalRelevantTags) const
{
	if (!Super::CanActivateAbility(Handle, ActorInfo, SourceTags, TargetTags, OptionalRelevantTags))
	{
		return false;
	}

	// 캐릭터가 점프 가능한 상태인지 확인
	if (const AActionPracticeCharacter* Character = Cast<AActionPracticeCharacter>(ActorInfo->AvatarActor.Get()))
	{
		const UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
		if (!MovementComp)
		{
			return false;
		}

		// 땅에 있거나 더블 점프 가능한 경우
		if (!MovementComp->IsFalling())
		{
			return true; // 땅에서 첫 번째 점프
		}
		else if (bAllowDoubleJump && CurrentJumpCount < MaxJumpCount)
		{
			return true; // 공중에서 더블 점프
		}
	}

	return false;
}

void UJumpAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 스태미나 소모
	if (!ConsumeStamina())
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 점프 실행
	if (CanJump())
	{
		PerformJump();
	}
	else if (CanDoubleJump())
	{
		PerformDoubleJump();
	}
	else
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 착지 확인 타이머 시작
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(
			LandingCheckTimer,
			this,
			&UJumpAbility::CheckForLanding,
			0.1f,
			true
		);
	}

	// 점프는 즉시 완료되므로 바로 종료
	EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
}

void UJumpAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	// 타이머 정리는 착지 시에 처리

	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void UJumpAbility::PerformJump()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		return;
	}

	// 점프 속도 설정
	MovementComp->JumpZVelocity = JumpZVelocity;

	// 점프 실행
	Character->Jump();

	// 점프 횟수 증가
	CurrentJumpCount++;
	JumpStartTime = GetWorld()->GetTimeSeconds();

	UE_LOG(LogTemp, Warning, TEXT("Jump performed - Count: %d, Velocity: %f"), CurrentJumpCount, JumpZVelocity);
}

void UJumpAbility::PerformDoubleJump()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		return;
	}

	// 더블 점프 속도 계산
	float DoubleJumpVelocity = JumpZVelocity * DoubleJumpMultiplier;

	// 현재 수직 속도를 리셋하고 더블 점프 적용
	FVector CurrentVelocity = MovementComp->Velocity;
	CurrentVelocity.Z = DoubleJumpVelocity;
	MovementComp->Velocity = CurrentVelocity;

	// 점프 횟수 증가
	CurrentJumpCount++;
	JumpStartTime = GetWorld()->GetTimeSeconds();

	UE_LOG(LogTemp, Warning, TEXT("Double jump performed - Count: %d, Velocity: %f"), CurrentJumpCount, DoubleJumpVelocity);
}

bool UJumpAbility::CanJump() const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return false;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		return false;
	}

	// 땅에 있고 첫 번째 점프인 경우
	return !MovementComp->IsFalling() && CurrentJumpCount == 0;
}

bool UJumpAbility::CanDoubleJump() const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character || !bAllowDoubleJump)
	{
		return false;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		return false;
	}

	// 공중에 있고 더블 점프 가능한 경우
	return MovementComp->IsFalling() && CurrentJumpCount > 0 && CurrentJumpCount < MaxJumpCount;
}

void UJumpAbility::OnLanded()
{
	// 점프 횟수 리셋
	CurrentJumpCount = 0;

	// 착지 확인 타이머 정리
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(LandingCheckTimer);
	}

	UE_LOG(LogTemp, Warning, TEXT("Landed - Jump count reset"));
}

void UJumpAbility::CheckForLanding()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		return;
	}

	// 착지했는지 확인
	if (!MovementComp->IsFalling() && CurrentJumpCount > 0)
	{
		OnLanded();
	}
}

================
File: ActionPractice\Private\GAS\Abilities\RollAbility.cpp
================
#include "GAS/Abilities/RollAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "AbilitySystemComponent.h"
#include "Animation/AnimMontage.h"
#include "Animation/AnimInstance.h"
#include "Components/SkeletalMeshComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Engine/World.h"
#include "TimerManager.h"
#include "GAS/GameplayTagsSubsystem.h"

URollAbility::URollAbility()
{
	// GameplayTag는 Blueprint에서 설정
	
	// 스태미나 비용
	StaminaCost = 20.0f;
	
	// 기본값 설정
	RollDistance = 400.0f;
	RollSpeed = 800.0f;
	InvincibilityFrames = 0.5f;
	RecoveryTime = 0.3f;
}

void URollAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 스태미나 소모
	if (!ConsumeStamina())
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	// 구르기 실행
	PerformRoll();
}

void URollAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	// 무적 상태 종료
	EndInvincibility();

	// 타이머 정리
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(InvincibilityTimer);
	}

	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void URollAbility::PerformRoll()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character || !RollMontage)
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
		return;
	}

	UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
	if (!AnimInstance)
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
		return;
	}

	// 구르기 방향 계산
	FVector RollDirection = CalculateRollDirection();
	
	// 캐릭터 회전 설정
	if (RollDirection.Size() > 0.1f)
	{
		Character->SetActorRotation(RollDirection.Rotation());
	}

	// 몽타주 재생
	if (!MontageEndedDelegate.IsBound())
	{
		MontageEndedDelegate = FOnMontageEnded::CreateUObject(this, &URollAbility::OnMontageEnded);
		AnimInstance->Montage_SetEndDelegate(MontageEndedDelegate, RollMontage);
	}

	AnimInstance->Montage_Play(RollMontage);

	// 구르기 시작 시간 기록
	RollStartTime = GetWorld()->GetTimeSeconds();

	// 무적 상태 시작
	StartInvincibility();

	// 이동 임펄스 적용 (더 자연스러운 구르기 위해)
	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (MovementComp)
	{
		// 중력 일시 감소 (구르기 느낌)
		float OriginalGravity = MovementComp->GravityScale;
		MovementComp->GravityScale = 0.5f;
		
		// 구르기 후 중력 복구
		FTimerHandle GravityTimer;
		GetWorld()->GetTimerManager().SetTimer(
			GravityTimer,
			[MovementComp, OriginalGravity]()
			{
				if (MovementComp)
				{
					MovementComp->GravityScale = OriginalGravity;
				}
			},
			0.8f,
			false
		);

		// 구르기 방향으로 임펄스 적용
		FVector LaunchVelocity = RollDirection * RollSpeed;
		LaunchVelocity.Z = 0.0f; // 수평 이동만
		Character->LaunchCharacter(LaunchVelocity, true, true);
	}

	UE_LOG(LogTemp, Warning, TEXT("Roll performed in direction: %s"), *RollDirection.ToString());
}

FVector URollAbility::CalculateRollDirection() const
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return FVector::ForwardVector;
	}

	// 입력 방향 가져오기 (현재 캐릭터의 MovementInputVector 사용)
	// 실제로는 Enhanced Input에서 직접 가져와야 하지만, 여기서는 캐릭터의 현재 이동 방향 사용
	FVector InputDirection = Character->GetVelocity();
	InputDirection.Z = 0.0f;
	InputDirection.Normalize();

	// 입력이 없으면 캐릭터가 바라보는 방향으로
	if (InputDirection.Size() < 0.1f)
	{
		InputDirection = Character->GetActorForwardVector();
	}

	return InputDirection;
}

void URollAbility::StartInvincibility()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	// 무적 태그 추가
	UAbilitySystemComponent* ASC = Character->GetAbilitySystemComponent();
	if (ASC)
	{
		ASC->AddLooseGameplayTag(UGameplayTagsSubsystem::GetStateInvincibleTag());
	}

	// 무적 상태 타이머 설정
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(
			InvincibilityTimer,
			this,
			&URollAbility::EndInvincibility,
			InvincibilityFrames,
			false
		);
	}

	UE_LOG(LogTemp, Warning, TEXT("Invincibility started for %f seconds"), InvincibilityFrames);
}

void URollAbility::EndInvincibility()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	// 무적 태그 제거
	UAbilitySystemComponent* ASC = Character->GetAbilitySystemComponent();
	if (ASC)
	{
		ASC->RemoveLooseGameplayTag(UGameplayTagsSubsystem::GetStateInvincibleTag());
	}

	UE_LOG(LogTemp, Warning, TEXT("Invincibility ended"));
}

void URollAbility::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	if (Montage == RollMontage)
	{
		// 회복 시간 후 어빌리티 종료
		if (GetWorld())
		{
			FTimerHandle RecoveryTimer;
			GetWorld()->GetTimerManager().SetTimer(
				RecoveryTimer,
				[this]()
				{
					EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
				},
				RecoveryTime,
				false
			);
		}
		else
		{
			EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, bInterrupted);
		}
	}
}

================
File: ActionPractice\Private\GAS\Abilities\SprintAbility.cpp
================
#include "GAS/Abilities/SprintAbility.h"
#include "Characters/ActionPracticeCharacter.h"
#include "GAS/ActionPracticeAttributeSet.h"
#include "AbilitySystemComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Engine/World.h"
#include "TimerManager.h"

#define ENABLE_DEBUG_LOG 1

#if ENABLE_DEBUG_LOG
	#define DEBUG_LOG(Format, ...) UE_LOG(LogAbilitySystemComponent, Warning, Format, ##__VA_ARGS__)
#else
	#define DEBUG_LOG(Format, ...)
#endif

USprintAbility::USprintAbility()
{
	// GameplayTag는 Blueprint에서 설정
	
	// 초기 스태미나 비용 없음 (지속적으로 소모)
	StaminaCost = 0.0f;
	
	// 기본값 설정
	SprintSpeedMultiplier = 1.5f;
	StaminaDrainPerSecond = 12.0f;
	MinStaminaToStart = 10.0f;
	MinStaminaToContinue = 5.0f;

	// 인스턴싱 정책: 지속적인 어빌리티이므로 액터별 인스턴스
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
}

bool USprintAbility::CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags, const FGameplayTagContainer* TargetTags, OUT FGameplayTagContainer* OptionalRelevantTags) const
{
	if (!Super::CanActivateAbility(Handle, ActorInfo, SourceTags, TargetTags, OptionalRelevantTags))
	{
		return false;
	}

	// 최소 스태미나 확인
	if (const UActionPracticeAttributeSet* AttributeSet = Cast<UActionPracticeAttributeSet>(ActorInfo->AbilitySystemComponent->GetAttributeSet(UActionPracticeAttributeSet::StaticClass())))
	{
		return AttributeSet->GetStamina() >= MinStaminaToStart;
	}

	return false;
}

void USprintAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		return;
	}

	SprintSpeedMultiplier = Character->SprintSpeedMultiplier;
	// 스프린트 시작
	StartSprinting();
}

void USprintAbility::InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo)
{
	DEBUG_LOG(TEXT("Sprint Input Released - Ending Ability"));
	EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
}

void USprintAbility::CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,	const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility)
{
	DEBUG_LOG(TEXT("sprint cancel"));
	Super::CancelAbility(Handle, ActorInfo, ActivationInfo, bReplicateCancelAbility);
}

void USprintAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	// 스프린트 종료
	StopSprinting();
	DEBUG_LOG(TEXT("sprint end"));
	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void USprintAbility::StartSprinting()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (!Character)
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
		return;
	}

	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (!MovementComp)
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, true);
		return;
	}

	// 원래 이동 속도 저장
	OriginalMaxWalkSpeed = MovementComp->MaxWalkSpeed;

	// 스프린트 속도 적용
	MovementComp->MaxWalkSpeed = OriginalMaxWalkSpeed * SprintSpeedMultiplier;

	// 스태미나 소모 타이머 시작
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(
			StaminaDrainTimer,
			this,
			&USprintAbility::DrainStamina,
			1.0f / StaminaDrainPerSecond,
			true
		);

		// 스프린트 조건 확인 타이머 시작 (더 자주 체크)
		GetWorld()->GetTimerManager().SetTimer(
			SprintCheckTimer,
			this,
			&USprintAbility::CheckSprintConditions,
			0.1f,
			true
		);
	}

	UE_LOG(LogTemp, Warning, TEXT("Sprint started - Speed: %f"), MovementComp->MaxWalkSpeed);
}

void USprintAbility::StopSprinting()
{
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();
	if (Character)
	{
		UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
		if (MovementComp && OriginalMaxWalkSpeed > 0.0f)
		{
			// 원래 이동 속도 복구
			MovementComp->MaxWalkSpeed = OriginalMaxWalkSpeed;
		}
	}

	// 타이머 정리
	if (GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(StaminaDrainTimer);
		GetWorld()->GetTimerManager().ClearTimer(SprintCheckTimer);
	}

	UE_LOG(LogTemp, Warning, TEXT("Sprint ended"));
}

void USprintAbility::HandleSprinting()
{
	// 스프린트 중 추가 처리가 필요하면 여기에 구현
}

bool USprintAbility::CanContinueSprinting() const
{
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	AActionPracticeCharacter* Character = GetActionPracticeCharacterFromActorInfo();

	if (!AttributeSet || !Character)
	{
		return false;
	}

	// 스태미나 확인
	if (AttributeSet->GetStamina() < MinStaminaToContinue)
	{
		return false;
	}

	// 이동 입력 확인 (실제로는 Enhanced Input에서 확인해야 함)
	UCharacterMovementComponent* MovementComp = Character->GetCharacterMovement();
	if (MovementComp && MovementComp->GetCurrentAcceleration().Size() < 10.0f)
	{
		return false; // 이동 입력이 없으면 스프린트 중단
	}

	// 공중에 있으면 스프린트 불가
	if (MovementComp && MovementComp->IsFalling())
	{
		return false;
	}

	return true;
}

void USprintAbility::DrainStamina()
{
	UActionPracticeAttributeSet* AttributeSet = GetActionPracticeAttributeSetFromActorInfo();
	if (AttributeSet)
	{
		float CurrentStamina = AttributeSet->GetStamina();
		float NewStamina = FMath::Max(0.0f, CurrentStamina - 1.0f);
		const_cast<UActionPracticeAttributeSet*>(AttributeSet)->SetStamina(NewStamina);
	}
}

void USprintAbility::CheckSprintConditions()
{
	if (!CanContinueSprinting())
	{
		EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
	}
}

================
File: ActionPractice\Private\GAS\Abilities\Tasks\AbilityTask_PlayNormalAttackMontage.cpp
================
#include "GAS/Abilities/Tasks/AbilityTask_PlayNormalAttackMontage.h"
#include "GameFramework/Character.h"
#include "Components/SkeletalMeshComponent.h"
#include "Animation/AnimInstance.h"
#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "GAS/GameplayTagsSubsystem.h"

// 디버그 로그 활성화/비활성화 (0: 비활성화, 1: 활성화)
#define ENABLE_DEBUG_LOG 1

#if ENABLE_DEBUG_LOG
    #define DEBUG_LOG(Format, ...) UE_LOG(LogAbilitySystemComponent, Warning, Format, ##__VA_ARGS__)
#else
    #define DEBUG_LOG(Format, ...)
#endif

UAbilityTask_PlayNormalAttackMontage::UAbilityTask_PlayNormalAttackMontage(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    Rate = 1.0f;
    bStopMontageWhenAbilityCancelled = false;
    
    ComboCounter = 0;
    MaxComboCount = 3;
    bCanComboSave = false;
    bComboInputSaved = false;
    bIsInCancellableRecovery = false;
    bIsTransitioningToNextCombo = false;
    
    CurrentMontage = nullptr;
}

UAbilityTask_PlayNormalAttackMontage* UAbilityTask_PlayNormalAttackMontage::CreatePlayNormalAttackMontageProxy(
    UGameplayAbility* OwningAbility,
    FName TaskInstanceName,
    const TArray<TSoftObjectPtr<UAnimMontage>>& MontagesToPlay,
    float Rate,
    FName StartSection,
    float AnimRootMotionTranslationScale)
{
    UAbilitySystemGlobals::NonShipping_ApplyGlobalAbilityScaler_Rate(Rate);

    UAbilityTask_PlayNormalAttackMontage* MyTask = NewAbilityTask<UAbilityTask_PlayNormalAttackMontage>(OwningAbility, TaskInstanceName);
    MyTask->MontagesToPlay = MontagesToPlay;
    MyTask->Rate = Rate;
    MyTask->StartSectionName = StartSection;
    MyTask->AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;

    return MyTask;
}

void UAbilityTask_PlayNormalAttackMontage::Activate()
{
    if (Ability == nullptr)
    {
        return;
    }
    
    DEBUG_LOG(TEXT("Task Activate"));
    
    bool bPlayedMontage = false;
    
    if (AbilitySystemComponent.IsValid())
    {
        const FGameplayAbilityActorInfo* ActorInfo = Ability->GetCurrentActorInfo();
        UAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();

        if (AnimInstance != nullptr)
        {
            // 이벤트 콜백 등록
            RegisterGameplayEventCallbacks();
            
            // 첫 공격 실행
            PlayAttackMontage();
            bPlayedMontage = true;
        }
    }

    if (!bPlayedMontage)
    {
        if (ShouldBroadcastAbilityTaskDelegates())
        {
            OnCancelled.Broadcast();
        }
        EndTask();
    }

    SetWaitingOnAvatar();
}

/* 공격 수행 메커니즘
 * 1. 몽타주 실행 (State.IsAttacking 태그 추가)
 * 2. enablecomboInput = 입력 저장 가능 구간, 다음 공격과 구르기 저장 가능 (구르기를 저장해도 다음 공격 우선 저장)
 * 3. ActionRecoveryEnd = 공격 선딜이 끝나는 지점
 * 3-1. 2~3 사이 저장한 행동이 있을 경우 CheckComboInput으로 행동 수행
 * 3-2. 2~3 사이 저장한 행동이 없을 경우 입력이 들어오면 다음 공격 가능, 이동/점프/구르기로 캔슬 가능 (State.IsAttacking 태그 제거)
 * 4. ResetCombo = 공격 콤보가 초기화되어 다음 콤보로 연계되지 않음, 이후 바로 어빌리티 종료
 * 5. 몽타주 종료 (ResetCombo와 같지 않음)
 */
#pragma region "Attack Functions"
void UAbilityTask_PlayNormalAttackMontage::PlayAttackMontage()
{
    const FGameplayAbilityActorInfo* ActorInfo = Ability->GetCurrentActorInfo();
    UAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();
    
    if (!AnimInstance)
    {
        EndTask();
        return;
    }
    
    // 몽타주 배열 검증
    if (MontagesToPlay.IsEmpty() || ComboCounter >= MontagesToPlay.Num())
    {
        DEBUG_LOG(TEXT("Invalid montage array or combo counter"));
        EndTask();
        return;
    }
    
    // 이전 몽타주의 델리게이트 정리 (새 몽타주 로드 전에)
    UAnimMontage* PreviousMontage = CurrentMontage;
    if (PreviousMontage)
    {
        if (BlendingOutDelegate.IsBound())
        {
            FOnMontageBlendingOutStarted EmptyBlendDelegate;
            AnimInstance->Montage_SetBlendingOutDelegate(EmptyBlendDelegate, PreviousMontage);
            BlendingOutDelegate.Unbind();
        }
        if (MontageEndedDelegate.IsBound())
        {
            FOnMontageEnded EmptyEndDelegate;
            AnimInstance->Montage_SetEndDelegate(EmptyEndDelegate, PreviousMontage);
            MontageEndedDelegate.Unbind();
        }
        DEBUG_LOG(TEXT("Cleared delegates for previous montage: %s"), *PreviousMontage->GetName());
    }
    
    // 현재 콤보에 해당하는 몽타주 로드
    CurrentMontage = MontagesToPlay[ComboCounter].LoadSynchronous();
    if (!CurrentMontage)
    {
        DEBUG_LOG(TEXT("Failed to load montage at index %d"), ComboCounter);
        EndTask();
        return;
    }

    bComboInputSaved = false;
    bCanComboSave = false;
    bIsInCancellableRecovery = false;
    // bIsTransitioningToNextCombo는 OnMontageEnded에서만 리셋 (타이밍 문제 방지)

    if (AbilitySystemComponent.IsValid())
    {
        AbilitySystemComponent->AddLooseGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag());
    }
    
    float PlayLength = AnimInstance->Montage_Play(CurrentMontage, Rate);
    DEBUG_LOG(TEXT("Montage Play Result: %f, Montage Name: %s"), PlayLength, CurrentMontage ? *CurrentMontage->GetName() : TEXT("NULL"));

    // 블렌드 아웃 델리게이트 바인딩
    BlendingOutDelegate = FOnMontageBlendingOutStarted::CreateUObject(this, &UAbilityTask_PlayNormalAttackMontage::OnMontageBlendingOut);
    AnimInstance->Montage_SetBlendingOutDelegate(BlendingOutDelegate, CurrentMontage);
    DEBUG_LOG(TEXT("BlendingOutDelegate Bound Successfully"));

    // 몽타주 종료 델리게이트 바인딩
    MontageEndedDelegate = FOnMontageEnded::CreateUObject(this, &UAbilityTask_PlayNormalAttackMontage::OnMontageEnded);
    AnimInstance->Montage_SetEndDelegate(MontageEndedDelegate, CurrentMontage);
    DEBUG_LOG(TEXT("MontageEndedDelegate Bound Successfully"));

    ACharacter* Character = Cast<ACharacter>(GetAvatarActor());
    if (Character && (Character->GetLocalRole() == ROLE_Authority ||
        (Character->GetLocalRole() == ROLE_AutonomousProxy && 
         Ability->GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))
    {
        Character->SetAnimRootMotionTranslationScale(AnimRootMotionTranslationScale);
    }

    // 콤보 실행 알림
    if (ShouldBroadcastAbilityTaskDelegates())
    {
        OnComboPerformed.Broadcast();
    }
    
    DEBUG_LOG(TEXT("Attack Monatage First Played"));
}

void UAbilityTask_PlayNormalAttackMontage::PlayNextAttackCombo()
{
    ComboCounter++;
    
    if (ComboCounter >= MaxComboCount)
    {
        DEBUG_LOG(TEXT("Max combo reached - ending task"));
        EndTask();
        return;
    }
    
    // 몽타주 전환 플래그 설정 (델리게이트에서 OnInterrupted 무시하기 위함)
    bIsTransitioningToNextCombo = true;
    
    DEBUG_LOG(TEXT("Starting combo %d transition"), ComboCounter + 1);
    
    // PlayAttackMontage를 재사용하여 다음 몽타주 재생
    PlayAttackMontage();
}

void UAbilityTask_PlayNormalAttackMontage::CheckComboInputPreseed() //어빌리티 실행 중 입력이 들어올 때
{
    // 2. enablecomboInput 구간에서 입력이 들어오면 저장
    if (bCanComboSave)
    {
        bComboInputSaved = true;
        bCanComboSave = false;
        
        DEBUG_LOG(TEXT("Combo Saved"));
    }
    // 3-2. ActionRecoveryEnd 이후 구간에서 입력이 들어오면 콤보 실행
    else if (bIsInCancellableRecovery)
    {
        PlayNextAttackCombo();

        DEBUG_LOG(TEXT("Combo Played After Recovery"));
    }
}

#pragma endregion

#pragma region "AnimNotify Event Functions"
void UAbilityTask_PlayNormalAttackMontage::HandleEnableComboInputEvent(const FGameplayEventData& Payload)
{
    bCanComboSave = true;
}

void UAbilityTask_PlayNormalAttackMontage::HandleActionRecoveryEndEvent(const FGameplayEventData& Payload)
{
    bCanComboSave = false;

    // 3-1. 2~3 사이 저장한 행동이 있을 경우
    if (bComboInputSaved)
    {
        PlayNextAttackCombo();

        DEBUG_LOG(TEXT("Combo Played With Saved"));
    }
    // 3-2. 저장한 행동이 없을 경우
    else
    {
        if (AbilitySystemComponent.IsValid())
        {
            // 모든 StateRecovering 태그 제거 (스택된 태그 모두 제거)
            while (AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag()))
            {
                AbilitySystemComponent->RemoveLooseGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag());
            }
            DEBUG_LOG(TEXT("Can ABP Interrupt Attack Montage"));
        }
 
        bIsInCancellableRecovery = true;
    }
}

// 4. ResetCombo 이벤트 수신
void UAbilityTask_PlayNormalAttackMontage::HandleResetComboEvent(const FGameplayEventData& Payload)
{    
    // EndTask()를 바로 호출하지 않고 몽타주 종료를 기다림
    if (ShouldBroadcastAbilityTaskDelegates())
    {
        OnCompleted.Broadcast();
    }
}

void UAbilityTask_PlayNormalAttackMontage::RegisterGameplayEventCallbacks()
{
    if (AbilitySystemComponent.IsValid() && Ability)
    {
        // EnableComboInput 이벤트 - Lambda 사용
        EnableComboInputHandle = AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyEnableComboInputTag())
            .AddLambda([this](const FGameplayEventData* EventData)
            {
                if (IsValid(this) && EventData)
                {
                    HandleEnableComboInputEvent(*EventData);
                }
            });

        // ActionRecoveryEnd 이벤트 - Lambda 사용
        ActionRecoveryEndHandle = AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyActionRecoveryEndTag())
            .AddLambda([this](const FGameplayEventData* EventData)
            {
                if (IsValid(this) && EventData)
                {
                    HandleActionRecoveryEndEvent(*EventData);
                }
            });

        // ResetCombo 이벤트 - Lambda 사용
        ResetComboHandle = AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyResetComboTag())
            .AddLambda([this](const FGameplayEventData* EventData)
            {
                if (IsValid(this) && EventData)
                {
                    HandleResetComboEvent(*EventData);
                }
            });
    }
}

void UAbilityTask_PlayNormalAttackMontage::UnregisterGameplayEventCallbacks()
{
    if (AbilitySystemComponent.IsValid())
    {
        if (EnableComboInputHandle.IsValid())
        {
            AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyEnableComboInputTag())
                .Remove(EnableComboInputHandle);
        }

        if (ActionRecoveryEndHandle.IsValid())
        {
            AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyActionRecoveryEndTag())
                .Remove(ActionRecoveryEndHandle);
        }

        if (ResetComboHandle.IsValid())
        {
            AbilitySystemComponent->GenericGameplayEventCallbacks.FindOrAdd(UGameplayTagsSubsystem::GetEventNotifyResetComboTag())
                .Remove(ResetComboHandle);
        }
    }
}
#pragma endregion

#pragma region "Montage Functions"
void UAbilityTask_PlayNormalAttackMontage::StopPlayingMontage()
{
    const FGameplayAbilityActorInfo* ActorInfo = Ability->GetCurrentActorInfo();
    if (!ActorInfo)
    {
        return;
    }

    UAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();
    if (AnimInstance && CurrentMontage)
    {
        float BlendOutTime = CurrentMontage->BlendOut.GetBlendTime();
        AnimInstance->Montage_Stop(BlendOutTime, CurrentMontage);
    }
}

void UAbilityTask_PlayNormalAttackMontage::OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted)
{
    DEBUG_LOG(TEXT("OnMontageBlendingOut Called - Montage: %s, Interrupted: %s"), 
           Montage ? *Montage->GetName() : TEXT("None"), 
           bInterrupted ? TEXT("True") : TEXT("False"));
           
    if (Ability && Ability->GetCurrentMontage() == CurrentMontage)
    {
        if (Montage == CurrentMontage)
        {
            AbilitySystemComponent->ClearAnimatingAbility(Ability);

            ACharacter* Character = Cast<ACharacter>(GetAvatarActor());
            if (Character && (Character->GetLocalRole() == ROLE_Authority ||
                (Character->GetLocalRole() == ROLE_AutonomousProxy && 
                 Ability->GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))
            {
                Character->SetAnimRootMotionTranslationScale(1.0f);
            }
        }
    }

    if (bInterrupted)
    {
        // 콤보 전환이 아닌 경우에만 OnInterrupted 브로드캐스트
        if (!bIsTransitioningToNextCombo && ShouldBroadcastAbilityTaskDelegates())
        {
            OnInterrupted.Broadcast();
        }
    }
    else
    {
        if (ShouldBroadcastAbilityTaskDelegates())
        {
            OnBlendOut.Broadcast();
        }
    }
}

void UAbilityTask_PlayNormalAttackMontage::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
    DEBUG_LOG(TEXT("OnMontageEnded Called - Montage: %s, Interrupted: %s"), 
           Montage ? *Montage->GetName() : TEXT("None"), 
           bInterrupted ? TEXT("True") : TEXT("False"));
    
    // 콤보 전환으로 인한 종료인지 확인
    if (bIsTransitioningToNextCombo && bInterrupted)
    {
        DEBUG_LOG(TEXT("Combo transition detected - not ending task"));
        bIsTransitioningToNextCombo = false; // 플래그 리셋
        return; // 콤보 진행 중이므로 태스크 종료하지 않음
    }
           
    if (!bInterrupted)
    {
        if (ShouldBroadcastAbilityTaskDelegates())
        {
            OnCompleted.Broadcast();
        }
    }
    else
    {
        // 콤보 전환이 아닌 경우에만 OnInterrupted 브로드캐스트
        if (!bIsTransitioningToNextCombo && ShouldBroadcastAbilityTaskDelegates())
        {
            OnInterrupted.Broadcast();
        }
    }

    EndTask();
}

void UAbilityTask_PlayNormalAttackMontage::ExternalCancel()
{
    if (ShouldBroadcastAbilityTaskDelegates())
    {
        OnCancelled.Broadcast();
    }

    Super::ExternalCancel();
}
#pragma endregion

void UAbilityTask_PlayNormalAttackMontage::OnDestroy(bool AbilityEnded)
{
    DEBUG_LOG(TEXT("Normal Attack Task Destroyed"));

    // 몽타주 정지
    if (bStopMontageWhenAbilityCancelled)
    {
        StopPlayingMontage();
    }
    
    // 이벤트 콜백 해제
    UnregisterGameplayEventCallbacks();
    
    // 몽타주 델리게이트 정리
    const FGameplayAbilityActorInfo* ActorInfo = Ability ? Ability->GetCurrentActorInfo() : nullptr;
    if (ActorInfo)
    {
        UAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();
        if (AnimInstance && CurrentMontage)
        {
            if (BlendingOutDelegate.IsBound())
            {
                FOnMontageBlendingOutStarted EmptyBlendDelegate;
                AnimInstance->Montage_SetBlendingOutDelegate(EmptyBlendDelegate, CurrentMontage);
                BlendingOutDelegate.Unbind();
            }
            if (MontageEndedDelegate.IsBound())
            {
                FOnMontageEnded EmptyEndDelegate;
                AnimInstance->Montage_SetEndDelegate(EmptyEndDelegate, CurrentMontage);
                MontageEndedDelegate.Unbind();
            }
        }
    }
    
    // 상태 정리 - 모든 StateRecovering 태그 제거
    if (AbilitySystemComponent.IsValid())
    {
        while (AbilitySystemComponent->HasMatchingGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag()))
        {
            AbilitySystemComponent->RemoveLooseGameplayTag(UGameplayTagsSubsystem::GetStateRecoveringTag());
        }
        DEBUG_LOG(TEXT("All StateRecovering tags removed"));
    }
    
    bCanComboSave = false;
    bComboInputSaved = false;
    bIsInCancellableRecovery = false;
    bIsTransitioningToNextCombo = false;
    bStopMontageWhenAbilityCancelled = false;
    
    // 포인터 정리
    CurrentMontage = nullptr;
    MontagesToPlay.Empty();

    Super::OnDestroy(AbilityEnded);
}

================
File: ActionPractice\Private\Items\Weapon.cpp
================
#include "Public/Items/Weapon.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/Engine.h"
#include "Engine/StaticMesh.h"
#include "Math/UnrealMathUtility.h"

AWeapon::AWeapon()
{
    PrimaryActorTick.bCanEverTick = true;

    // Static Mesh Component 생성 및 RootComponent로 설정
    WeaponMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("WeaponMesh"));
    RootComponent = WeaponMesh;

    // 콜리전 설정 - 메시 모양 그대로 사용
    WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
    WeaponMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);
    WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
    
    // 메시의 실제 형태를 콜리전으로 사용 (Complex Collision)
    WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Block);
    WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Block);
    
    // Complex Collision 사용 설정 (메시 모양 그대로)
    WeaponMesh->SetGenerateOverlapEvents(true);
    WeaponMesh->SetNotifyRigidBodyCollision(true);
    
    // Hit 이벤트 바인딩
    WeaponMesh->OnComponentHit.AddDynamic(this, &AWeapon::OnHit);
    
    WeaponName = TEXT("DefaultWeapon");
}

void AWeapon::BeginPlay()
{
    Super::BeginPlay();
    
    // 런타임에서 Complex Collision 설정 강제 적용
    if (WeaponMesh && WeaponMesh->GetStaticMesh())
    {
        // 메시의 실제 형태를 Simple Collision으로도 사용
        //WeaponMesh->GetStaticMesh()->GetBodySetup()->CollisionTraceFlag = ECollisionTraceFlag::CTF_UseComplexAsSimple;
        
        // 콜리전 업데이트
        WeaponMesh->UpdateCollisionFromStaticMesh();
    }
}

void AWeapon::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
}

const FBlockActionData* AWeapon::GetWeaponBlockData() const
{
    if (!WeaponData) return nullptr;

    return &WeaponData->BlockData;
}


const FAttackActionData* AWeapon::GetWeaponAttackDataByTag(FGameplayTag AttackTag) const
{
    if (!WeaponData) return nullptr;
    
    return WeaponData->AttackDataMap.Find(AttackTag);
}


void AWeapon::EquipWeapon()
{    
    // 여기에 무기별 고유 로직을 추가할 수 있습니다
    // 예: 몽타주 재생, 이펙트 재생, 사운드 재생, 데미지 처리 등
}

void AWeapon::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
    if (OtherActor && OtherActor != this)
    {
        UE_LOG(LogTemp, Warning, TEXT("Weapon %s hit %s"), *WeaponName, *OtherActor->GetName());
        // 여기에 히트 처리 로직 추가
        // 예: 데미지 처리, 이펙트 재생 등
    }
}

================
File: ActionPractice\Private\Notifies\AnimNotify_ActionRecoveryEnd.cpp
================
// Fill out your copyright notice in the Description page of Project Settings.


#include "Notifies/AnimNotify_ActionRecoveryEnd.h"
#include "Characters/ActionPracticeCharacter.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayTagContainer.h"
#include "GAS/GameplayTagsSubsystem.h"

void UAnimNotify_ActionRecoveryEnd::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	if (MeshComp && MeshComp->GetOwner())
	{
		UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
			MeshComp->GetOwner(), 
			UGameplayTagsSubsystem::GetEventNotifyActionRecoveryEndTag(), 
			FGameplayEventData()
		);
	}
}

================
File: ActionPractice\Private\Notifies\AnimNotify_EnableComboInput.cpp
================
// Fill out your copyright notice in the Description page of Project Settings.


#include "Notifies/AnimNotify_EnableComboInput.h"
#include "Characters/ActionPracticeCharacter.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayTagContainer.h"
#include "GAS/GameplayTagsSubsystem.h"

void UAnimNotify_EnableComboInput::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	if (MeshComp && MeshComp->GetOwner())
	{
		UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
			MeshComp->GetOwner(), 
			UGameplayTagsSubsystem::GetEventNotifyEnableComboInputTag(), 
			FGameplayEventData()
		);
	}
}

================
File: ActionPractice\Private\Notifies\AnimNotify_ResetCombo.cpp
================
#include "Notifies/AnimNotify_ResetCombo.h"
#include "Characters/ActionPracticeCharacter.h"
#include "AbilitySystemBlueprintLibrary.h"
#include "GameplayTagContainer.h"
#include "GAS/GameplayTagsSubsystem.h"

void UAnimNotify_ResetCombo::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	if (MeshComp && MeshComp->GetOwner())
	{
		UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(
			MeshComp->GetOwner(), 
			UGameplayTagsSubsystem::GetEventNotifyResetComboTag(), 
			FGameplayEventData()
		);
	}
}

================
File: ActionPractice\Public\Characters\ActionPracticeCharacter.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Public/Items/Weapon.h"
#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Logging/LogMacros.h"
#include "AbilitySystemInterface.h"
#include "GameplayEffect.h"
#include "GameplayTagContainer.h"
#include "ActionPracticeCharacter.generated.h"

class USpringArmComponent;
class UCameraComponent;
class UInputAction;
struct FInputActionValue;
class UAbilitySystemComponent;
class UActionPracticeAttributeSet;
class UGameplayAbility;

DECLARE_LOG_CATEGORY_EXTERN(LogTemplateCharacter, Log, All); 

UCLASS(abstract)
class AActionPracticeCharacter : public ACharacter, public IAbilitySystemInterface
{
	GENERATED_BODY()

	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	USpringArmComponent* CameraBoom;

	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	UCameraComponent* FollowCamera;

	/** Ability System Component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS", meta = (AllowPrivateAccess = "true"))
	UAbilitySystemComponent* AbilitySystemComponent;

	/** Attribute Set */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS", meta = (AllowPrivateAccess = "true"))
	UActionPracticeAttributeSet* AttributeSet;

public:
#pragma region "Public Variables"
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon")
	FString WeaponBlueprintBasePath = TEXT("/Game/Items/BluePrint/");

	// ===== Movement Properties =====
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Movement")
	float WalkSpeed = 400.0f;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Movement")
	float SprintSpeedMultiplier = 1.5f;
    
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Movement")
	float CrouchSpeedMultiplier = 0.5f;
    
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Movement")
	float BlockingSpeedMultiplier = 1.0f;
#pragma endregion
	
#pragma region "Public Functions"
	
	AActionPracticeCharacter();
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaSeconds) override;
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	// ===== Return Functions =====
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }	
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }

	// ===== GAS Interface =====
	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;
	FORCEINLINE UActionPracticeAttributeSet* GetAttributeSet() const { return AttributeSet; }

	// ===== Weapon Getter Functions =====
	FORCEINLINE AWeapon* GetLeftWeapon() const { return LeftWeapon; }
	FORCEINLINE AWeapon* GetRightWeapon() const { return RightWeapon; }

	// ===== Weapon Functions =====
	UFUNCTION(BlueprintCallable, Category = "Weapon")
	TSubclassOf<AWeapon> LoadWeaponClassByName(const FString& WeaponName);
	
	UFUNCTION(BlueprintCallable, Category = "Weapon")
	void EquipWeapon(TSubclassOf<AWeapon> NewWeaponClass, bool bIsLeftHand = true, bool bIsTwoHanded = false);

	UFUNCTION(BlueprintCallable, Category = "Weapon")
	void UnequipWeapon(bool bIsLeftHand = true);
	
	// ===== GAS Functions =====
	UFUNCTION(BlueprintCallable, Category = "GAS")
	void InitializeAbilitySystem();

	UFUNCTION(BlueprintCallable, Category = "GAS")
	void GiveAbility(TSubclassOf<UGameplayAbility> AbilityClass);

	UFUNCTION(BlueprintCallable, Category = "GAS")
	void GASInputPressed(const UInputAction* InputAction);

	UFUNCTION(BlueprintCallable, Category = "GAS")
	void GASInputReleased(const UInputAction* InputAction);
	
#pragma endregion

protected:
#pragma region "Protected Variables"
	
	// ====== Input Actions ======
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Jump;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Move;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Look;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_LockOn;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Sprint;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Crouch;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Roll;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Attack;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_Block;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_WeaponSwitch;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* IA_ChargeAttack;
	
	// ===== State Variables =====
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Action State")
	bool bIsLockOn = false;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Action State")
	bool bIsSwitching = false;

	// ===== LockOn =====
	UPROPERTY(BlueprintReadOnly, Category = "Combat")
	AActor* LockedOnTarget = nullptr;
	
	FVector2D MovementInputVector;
	
	// ===== Weapon Properties =====
	UPROPERTY(BlueprintReadOnly, Category = "Weapon")
	TSubclassOf<AWeapon> WeaponClass = nullptr;
	
	UPROPERTY(BlueprintReadOnly, Category = "Weapon")
	AWeapon* LeftWeapon = nullptr;
    
	UPROPERTY(BlueprintReadOnly, Category = "Weapon")
	AWeapon* RightWeapon = nullptr;

	// ===== GAS Properties =====
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GAS")
	TArray<TSubclassOf<UGameplayAbility>> StartAbilities;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GAS")
	TMap<UInputAction*, TSubclassOf<UGameplayAbility>> StartInputAbilities;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GAS")
	TArray<TSubclassOf<UGameplayEffect>> StartEffects;
	
#pragma endregion

#pragma region "Protected Functions"
	
	// ===== Input Handler Functions =====
	void Move(const FInputActionValue& Value);
	void Look(const FInputActionValue& Value);
	void ToggleLockOn();
	void WeaponSwitch();

	// ===== Input Handler Additional Functions =====
	void CancelActionForMove();
	AActor* FindNearestTarget();
	void UpdateLockOnCamera();
	
	// ===== GAS Input Handler Functions =====
	void OnJumpInput();
	void OnSprintInput();
	void OnSprintInputReleased();
	void OnCrouchInput();
	void OnRollInput();
	void OnAttackInput();
	void OnBlockInput();
	void OnBlockInputReleased();
	void OnChargeAttackInput();
	void OnChargeAttackReleased();
	
	// ===== Utility Functions =====

#pragma endregion

private:
#pragma region "Private Functions"

	
#pragma endregion
};

================
File: ActionPractice\Public\Games\ActionPracticeGameMode.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "ActionPracticeGameMode.generated.h"

/**
 *  Simple GameMode for a third person game
 */
UCLASS(abstract)
class AActionPracticeGameMode : public AGameModeBase
{
	GENERATED_BODY()

public:
	
	/** Constructor */
	AActionPracticeGameMode();
};

================
File: ActionPractice\Public\Games\ActionPracticePlayerController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "ActionPracticePlayerController.generated.h"

class UInputMappingContext;

/**
 *  Basic PlayerController class for a third person game
 *  Manages input mappings
 */
UCLASS(abstract)
class AActionPracticePlayerController : public APlayerController
{
	GENERATED_BODY()
	
protected:

	/** Input Mapping Contexts */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category ="Input", meta = (AllowPrivateAccess = "true"))
	TArray<UInputMappingContext*> DefaultMappingContexts;

	/** Input mapping context setup */
	virtual void SetupInputComponent() override;

};

================
File: ActionPractice\Public\GAS\ActionPracticeAttributeSet.h
================
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "AbilitySystemComponent.h"
#include "ActionPracticeAttributeSet.generated.h"

#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class ACTIONPRACTICE_API UActionPracticeAttributeSet : public UAttributeSet
{
	GENERATED_BODY()

public:
	UActionPracticeAttributeSet();

	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
	virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;

	// ===== Primary Attributes (엘든링 스타일) =====
	
	// Health (체력) - HP
	UPROPERTY(BlueprintReadOnly, Category = "Vital", ReplicatedUsing = OnRep_Health)
	FGameplayAttributeData Health;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, Health)

	UPROPERTY(BlueprintReadOnly, Category = "Vital", ReplicatedUsing = OnRep_MaxHealth)
	FGameplayAttributeData MaxHealth;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, MaxHealth)

	// Stamina (스태미나) - FP
	UPROPERTY(BlueprintReadOnly, Category = "Vital", ReplicatedUsing = OnRep_Stamina)
	FGameplayAttributeData Stamina;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, Stamina)

	UPROPERTY(BlueprintReadOnly, Category = "Vital", ReplicatedUsing = OnRep_MaxStamina)
	FGameplayAttributeData MaxStamina;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, MaxStamina)

	// Stamina Regeneration (스태미나 리젠)
	UPROPERTY(BlueprintReadOnly, Category = "Vital", ReplicatedUsing = OnRep_StaminaRegenRate)
	FGameplayAttributeData StaminaRegenRate;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, StaminaRegenRate)

	// Defense (방어력)
	UPROPERTY(BlueprintReadOnly, Category = "Combat", ReplicatedUsing = OnRep_Defense)
	FGameplayAttributeData Defense;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, Defense)

	// Strength (근력) - 무거운 무기, 방패에 영향
	UPROPERTY(BlueprintReadOnly, Category = "Stats", ReplicatedUsing = OnRep_Strength)
	FGameplayAttributeData Strength;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, Strength)

	// Dexterity (기량) - 빠른 무기, 활에 영향
	UPROPERTY(BlueprintReadOnly, Category = "Stats", ReplicatedUsing = OnRep_Dexterity)
	FGameplayAttributeData Dexterity;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, Dexterity)

	// ===== Secondary Attributes (계산된 능력치) =====
	
	// Physical Attack Power (물리 공격력)
	UPROPERTY(BlueprintReadOnly, Category = "Combat", ReplicatedUsing = OnRep_PhysicalAttackPower)
	FGameplayAttributeData PhysicalAttackPower;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, PhysicalAttackPower)

	// Movement Speed (이동 속도)
	UPROPERTY(BlueprintReadOnly, Category = "Movement", ReplicatedUsing = OnRep_MovementSpeed)
	FGameplayAttributeData MovementSpeed;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, MovementSpeed)

	// ===== Meta Attributes (계산용, 복제되지 않음) =====
	
	// Incoming Damage
	UPROPERTY(BlueprintReadOnly, Category = "Meta")
	FGameplayAttributeData IncomingDamage;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, IncomingDamage)

	// Incoming Healing
	UPROPERTY(BlueprintReadOnly, Category = "Meta")
	FGameplayAttributeData IncomingHealing;
	ATTRIBUTE_ACCESSORS(UActionPracticeAttributeSet, IncomingHealing)

protected:
	// Rep notifies
	UFUNCTION()
	virtual void OnRep_Health(const FGameplayAttributeData& OldHealth);

	UFUNCTION()
	virtual void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth);

	UFUNCTION()
	virtual void OnRep_Stamina(const FGameplayAttributeData& OldStamina);

	UFUNCTION()
	virtual void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina);

	UFUNCTION()
	virtual void OnRep_StaminaRegenRate(const FGameplayAttributeData& OldStaminaRegenRate);

	UFUNCTION()
	virtual void OnRep_Defense(const FGameplayAttributeData& OldDefense);

	UFUNCTION()
	virtual void OnRep_Strength(const FGameplayAttributeData& OldStrength);

	UFUNCTION()
	virtual void OnRep_Dexterity(const FGameplayAttributeData& OldDexterity);

	UFUNCTION()
	virtual void OnRep_PhysicalAttackPower(const FGameplayAttributeData& OldPhysicalAttackPower);

	UFUNCTION()
	virtual void OnRep_MovementSpeed(const FGameplayAttributeData& OldMovementSpeed);

	// Helper function to adjust attributes when max value changes
	void AdjustAttributeForMaxChange(FGameplayAttributeData& AffectedAttribute, const FGameplayAttributeData& MaxAttribute, float NewMaxValue, const FGameplayAttribute& AffectedAttributeProperty);

	// Calculate secondary attributes from primary stats
	void CalculateSecondaryAttributes();

public:
	// Helper functions for calculations
	UFUNCTION(BlueprintPure, Category = "Attributes")
	float GetHealthPercent() const;

	UFUNCTION(BlueprintPure, Category = "Attributes")
	float GetStaminaPercent() const;

	// Calculate weapon damage bonus based on stats
	UFUNCTION(BlueprintPure, Category = "Combat")
	float CalculateWeaponDamageBonus(float StrengthScaling, float DexterityScaling) const;
};

================
File: ActionPractice\Public\GAS\GameplayTagsDataAsset.h
================
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"
#include "GameplayTagsDataAsset.generated.h"

// 태그를 추가하면 에디터의 데이터 에셋에서 꼭 실제 태그를 바인딩할 것
UCLASS(BlueprintType)
class ACTIONPRACTICE_API UGameplayTagsDataAsset : public UDataAsset
{
	GENERATED_BODY()

public:
#pragma region "Ability Tags"
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Attack_Normal;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Attack_Charge;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Roll;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Sprint;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Jump;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability Tags")
	FGameplayTag Ability_Block
	;
#pragma endregion

#pragma region "State Tags"

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Attacking;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Blocking;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Sprinting;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Jumping;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Recovering;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Stunned;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "State Tags")
	FGameplayTag State_Invincible;
	
#pragma endregion

#pragma region "Event Tags"

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Tags")
	FGameplayTag Event_Notify_EnableComboInput;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Tags")
	FGameplayTag Event_Notify_ActionRecoveryEnd;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Event Tags")
	FGameplayTag Event_Notify_ResetCombo;
	
#pragma endregion
};

================
File: ActionPractice\Public\GAS\GameplayTagsSubsystem.h
================
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "GameplayTagContainer.h"
#include "GameplayTagsSubsystem.generated.h"

class UGameplayTagsDataAsset;

UCLASS()
class ACTIONPRACTICE_API UGameplayTagsSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	// Static 게임플레이 태그 접근 함수들
	
	// Ability Tags
	static const FGameplayTag& GetAbilityAttackNormalTag();
	static const FGameplayTag& GetAbilityAttackChargeTag();
	static const FGameplayTag& GetAbilityRollTag();
	static const FGameplayTag& GetAbilitySprintTag();
	static const FGameplayTag& GetAbilityJumpTag();
	static const FGameplayTag& GetAbilityBlockTag();
	
	// State Tags
	static const FGameplayTag& GetStateAttackingTag();
	static const FGameplayTag& GetStateBlockingTag();
	static const FGameplayTag& GetStateRecoveringTag();
	static const FGameplayTag& GetStateStunnedTag();
	static const FGameplayTag& GetStateInvincibleTag();
	static const FGameplayTag& GetStateJumpingTag();
	static const FGameplayTag& GetStateSprintingTag();
	
	// Event Tags
	static const FGameplayTag& GetEventNotifyEnableComboInputTag();
	static const FGameplayTag& GetEventNotifyActionRecoveryEndTag();
	static const FGameplayTag& GetEventNotifyResetComboTag();

private:
	// Internal helper function
	static UGameplayTagsSubsystem* Get();

	// 게임플레이 태그 접근 함수들 (인스턴스 버전)
	
	// Ability Tags
	const FGameplayTag& GetAbilityAttackNormalTagInternal() const;
	const FGameplayTag& GetAbilityAttackChargeTagInternal() const;
	const FGameplayTag& GetAbilityRollTagInternal() const;
	const FGameplayTag& GetAbilitySprintTagInternal() const;
	const FGameplayTag& GetAbilityJumpTagInternal() const;
	const FGameplayTag& GetAbilityBlockTagInternal() const;
	
	// State Tags
	const FGameplayTag& GetStateAttackingTagInternal() const;
	const FGameplayTag& GetStateBlockingTagInternal() const;
	const FGameplayTag& GetStateRecoveringTagInternal() const;
	const FGameplayTag& GetStateStunnedTagInternal() const;
	const FGameplayTag& GetStateInvincibleTagInternal() const;
	const FGameplayTag& GetStateJumpingTagInternal() const;
	const FGameplayTag& GetStateSprintingTagInternal() const;
	
	// Event Tags
	const FGameplayTag& GetEventNotifyEnableComboInputTagInternal() const;
	const FGameplayTag& GetEventNotifyActionRecoveryEndTagInternal() const;
	const FGameplayTag& GetEventNotifyResetComboTagInternal() const;

protected:
	// 태그 데이터 에셋
	UPROPERTY()
	TObjectPtr<UGameplayTagsDataAsset> GameplayTagsDataAsset;
};

================
File: ActionPractice\Public\GAS\Abilities\ActionPracticeGameplayAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "GameplayTagContainer.h"
#include "ActionPracticeGameplayAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API UActionPracticeGameplayAbility : public UGameplayAbility
{
	GENERATED_BODY()

public:
	UActionPracticeGameplayAbility();

protected:
	// 기본 클래스의 태그들을 사용하므로 여기서는 제거

	// 스태미나 비용
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Costs")
	float StaminaCost = 0.0f;

	// 쿨다운 시간
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Cooldown")
	float CooldownDuration = 0.0f;

	// 어빌리티 레벨
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Ability")
	int32 AbilityLevel = 1;

public:
	// 어빌리티 초기화
	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;

	// 어빌리티 활성화 가능 여부 확인
	virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override;

	// 스태미나 체크
	UFUNCTION(BlueprintPure, Category = "Ability")
	virtual bool CheckStaminaCost() const;

	// 스태미나 소모
	UFUNCTION(BlueprintCallable, Category = "Ability")
	virtual bool ConsumeStamina();

	// 어빌리티 활성화
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	// 어빌리티 종료
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

protected:
	// 캐릭터 레퍼런스 가져오기
	UFUNCTION(BlueprintPure, Category = "Ability")
	class AActionPracticeCharacter* GetActionPracticeCharacterFromActorInfo() const;

	// AttributeSet 레퍼런스 가져오기
	UFUNCTION(BlueprintPure, Category = "Ability")
	class UActionPracticeAttributeSet* GetActionPracticeAttributeSetFromActorInfo() const;
};

================
File: ActionPractice\Public\GAS\Abilities\AttackAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "Public/Items/WeaponData.h"
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "Engine/Engine.h"
#include "Tasks/AbilityTask_PlayNormalAttackMontage.h"
#include "AttackAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API UAttackAbility : public UActionPracticeGameplayAbility
{
	GENERATED_BODY()

public:
#pragma region "Public Functions" //==================================================
	
	UAttackAbility();
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;
	virtual void InputPressed(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override;
	virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,	const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) override;

#pragma endregion

protected:
#pragma region "Protected Vriables" //================================================
	
	const FAttackActionData* WeaponAttackData;

	
#pragma endregion

#pragma region "Protected Functions" //================================================

	// ===== Task Evenet Handler Functions =====
	
	UFUNCTION()
	void OnTaskCompleted();

	UFUNCTION()
	void OnTaskInterrupted();
	
	UFUNCTION()
	void OnComboPerformed();
	
#pragma endregion

private:
#pragma region "Private Variables"

	UPROPERTY()
	UAbilityTask_PlayNormalAttackMontage* NormalAttackTask;
	
#pragma endregion

#pragma region "Private Functions"

#pragma endregion
};

================
File: ActionPractice\Public\GAS\Abilities\BlockAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "BlockAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API UBlockAbility : public UActionPracticeGameplayAbility
{
	GENERATED_BODY()

public:
	UBlockAbility();

protected:
	// 방어 시작 몽타주
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	class UAnimMontage* BlockStartMontage;

	// 방어 유지 몽타주
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	class UAnimMontage* BlockIdleMontage;

	// 방어 종료 몽타주
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	class UAnimMontage* BlockEndMontage;

	// 방어 성공 몽타주 (패리 등)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	class UAnimMontage* BlockSuccessMontage;

	// 방어 실패 몽타주 (가드 브레이크)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	class UAnimMontage* BlockFailMontage;

	// 스태미나 소모량 (초당)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float StaminaDrainPerSecond = 5.0f;

	// 방어력 배율 (받는 데미지 감소)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float DamageReductionMultiplier = 0.8f; // 20% 데미지만 받음

	// 스태미나 데미지 감소율
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float StaminaDamageReduction = 0.5f; // 50% 스태미나 데미지만 받음

	// 이동 속도 배율
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float MovementSpeedMultiplier = 0.3f; // 30%로 속도 감소

	// 방어 각도 (정면 기준)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float BlockAngle = 120.0f; // 정면 120도

	// 패리 윈도우 시간
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float ParryWindow = 0.5f;

	// 가드 브레이크 임계값
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Block")
	float GuardBreakThreshold = 50.0f;

public:
	// 어빌리티 활성화
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	virtual void InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override;
	
	// 어빌리티 종료
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

protected:
	// 방어 시작
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void StartBlocking();

	// 방어 중 처리
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void HandleBlocking(float DeltaTime);

	// 방어 종료
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void StopBlocking();

	// 방어 성공 처리
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void HandleBlockSuccess(float IncomingDamage, AActor* DamageSource);

	// 패리 성공 처리
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void HandleParrySuccess(AActor* DamageSource);

	// 가드 브레이크 처리
	UFUNCTION(BlueprintCallable, Category = "Block")
	virtual void HandleGuardBreak();

	// 방어 방향 확인
	UFUNCTION(BlueprintPure, Category = "Block")
	virtual bool CanBlockFromDirection(const FVector& DamageDirection) const;

	// 방어력 계산
	UFUNCTION(BlueprintPure, Category = "Block")
	virtual float CalculateBlockEffectiveness() const;

	// 패리 윈도우 체크
	UFUNCTION(BlueprintPure, Category = "Block")
	virtual bool IsInParryWindow() const;

private:
	// 방어 시작 시간
	UPROPERTY()
	float BlockStartTime = 0.0f;

	// 방어 상태
	UPROPERTY()
	bool bIsBlocking = false;

	// 스태미나 타이머
	FTimerHandle StaminaDrainTimer;

	// 스태미나 소모 함수
	UFUNCTION()
	void DrainStamina();

	// 몽타주 종료 콜백
	UFUNCTION()
	void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);

	// 몽타주 종료 델리게이트 핸들
	FOnMontageEnded MontageEndedDelegate;
};

================
File: ActionPractice\Public\GAS\Abilities\JumpAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "JumpAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API UJumpAbility : public UActionPracticeGameplayAbility
{
	GENERATED_BODY()

public:
	UJumpAbility();

protected:
	// 점프 강도
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Jump")
	float JumpZVelocity = 600.0f;

	// 더블 점프 허용 여부
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Jump")
	bool bAllowDoubleJump = false;

	// 더블 점프 강도 배율
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Jump")
	float DoubleJumpMultiplier = 0.8f;

	// 최대 점프 횟수
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Jump")
	int32 MaxJumpCount = 1;

public:
	// 어빌리티 활성화 가능 여부 확인
	virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override;

	// 어빌리티 활성화
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	// 어빌리티 종료
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

protected:
	// 점프 실행
	UFUNCTION(BlueprintCallable, Category = "Jump")
	virtual void PerformJump();

	// 더블 점프 실행
	UFUNCTION(BlueprintCallable, Category = "Jump")
	virtual void PerformDoubleJump();

	// 점프 가능 여부 확인
	UFUNCTION(BlueprintPure, Category = "Jump")
	virtual bool CanJump() const;

	// 더블 점프 가능 여부 확인
	UFUNCTION(BlueprintPure, Category = "Jump")
	virtual bool CanDoubleJump() const;

	// 착지 감지
	UFUNCTION(BlueprintCallable, Category = "Jump")
	virtual void OnLanded();

private:
	// 현재 점프 횟수 (const 함수에서도 접근 가능하도록)
	UPROPERTY()
	mutable int32 CurrentJumpCount = 0;

	// 점프 시작 시간
	float JumpStartTime = 0.0f;

	// 착지 확인 타이머
	FTimerHandle LandingCheckTimer;

	// 착지 확인 함수
	UFUNCTION()
	void CheckForLanding();
};

================
File: ActionPractice\Public\GAS\Abilities\RollAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "RollAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API URollAbility : public UActionPracticeGameplayAbility
{
	GENERATED_BODY()

public:
	URollAbility();

protected:
	// 구르기 몽타주
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Roll")
	class UAnimMontage* RollMontage;

	// 구르기 거리
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Roll")
	float RollDistance = 400.0f;

	// 구르기 속도
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Roll")
	float RollSpeed = 800.0f;

	// 구르기 중 무적 시간
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Roll")
	float InvincibilityFrames = 0.5f;

	// 구르기 후 회복 시간
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Roll")
	float RecoveryTime = 0.3f;

public:
	// 어빌리티 활성화
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	// 어빌리티 종료
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

protected:
	// 구르기 실행
	UFUNCTION(BlueprintCallable, Category = "Roll")
	virtual void PerformRoll();

	// 구르기 방향 계산
	UFUNCTION(BlueprintPure, Category = "Roll")
	virtual FVector CalculateRollDirection() const;

	// 무적 상태 시작
	UFUNCTION(BlueprintCallable, Category = "Roll")
	virtual void StartInvincibility();

	// 무적 상태 종료
	UFUNCTION(BlueprintCallable, Category = "Roll")
	virtual void EndInvincibility();

private:
	// 몽타주 종료 콜백
	UFUNCTION()
	void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);

	// 무적 상태 타이머
	FTimerHandle InvincibilityTimer;

	// 몽타주 종료 델리게이트 핸들
	FOnMontageEnded MontageEndedDelegate;

	// 구르기 시작 시간
	float RollStartTime = 0.0f;
};

================
File: ActionPractice\Public\GAS\Abilities\SprintAbility.h
================
#pragma once

#include "CoreMinimal.h"
#include "GAS/Abilities/ActionPracticeGameplayAbility.h"
#include "SprintAbility.generated.h"

UCLASS()
class ACTIONPRACTICE_API USprintAbility : public UActionPracticeGameplayAbility
{
	GENERATED_BODY()

public:
	USprintAbility();

protected:
	// 스프린트 속도 배율
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Sprint")
	float SprintSpeedMultiplier = 1.5f;

	// 스프린트 중 스태미나 소모량 (초당)
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Sprint")
	float StaminaDrainPerSecond = 12.0f;

	// 스프린트 시작에 필요한 최소 스태미나
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Sprint")
	float MinStaminaToStart = 10.0f;

	// 스프린트 중지를 위한 최소 스태미나
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Sprint")
	float MinStaminaToContinue = 5.0f;

public:
	// 어빌리티 활성화 가능 여부 확인
	virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override;

	// 어빌리티 활성화
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,	const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility) override;

	virtual void InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override;
	
	// 어빌리티 종료
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

protected:
	// 스프린트 시작
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	virtual void StartSprinting();

	// 스프린트 종료
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	virtual void StopSprinting();

	// 스프린트 중 처리
	UFUNCTION(BlueprintCallable, Category = "Sprint")
	virtual void HandleSprinting();

	// 스프린트 가능 여부 확인
	UFUNCTION(BlueprintPure, Category = "Sprint")
	virtual bool CanContinueSprinting() const;

private:
	// 스태미나 소모 타이머
	FTimerHandle StaminaDrainTimer;

	// 스프린트 상태 확인 타이머
	FTimerHandle SprintCheckTimer;

	// 원래 이동 속도
	float OriginalMaxWalkSpeed = 0.0f;

	// 스태미나 소모 함수
	UFUNCTION()
	void DrainStamina();

	// 스프린트 상태 확인 함수
	UFUNCTION()
	void CheckSprintConditions();
};

================
File: ActionPractice\Public\GAS\Abilities\Tasks\AbilityTask_PlayNormalAttackMontage.h
================
#pragma once

#include "CoreMinimal.h"
#include "Abilities/Tasks/AbilityTask.h"
#include "GameplayTagContainer.h"
#include "Abilities/GameplayAbilityTypes.h"
#include "AbilityTask_PlayNormalAttackMontage.generated.h"

class UAnimMontage;

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FNormalAttackMontageDelegate);

UCLASS()
class ACTIONPRACTICE_API UAbilityTask_PlayNormalAttackMontage : public UAbilityTask
{
    GENERATED_BODY()

public:
#pragma region "Public Variables" //=======================================================
    
    // 델리게이트들
    UPROPERTY(BlueprintAssignable)
    FNormalAttackMontageDelegate OnCompleted;

    UPROPERTY(BlueprintAssignable)
    FNormalAttackMontageDelegate OnBlendOut;

    UPROPERTY(BlueprintAssignable)
    FNormalAttackMontageDelegate OnInterrupted;

    UPROPERTY(BlueprintAssignable)
    FNormalAttackMontageDelegate OnCancelled;

    // 콤보 진행시 호출
    UPROPERTY(BlueprintAssignable)
    FNormalAttackMontageDelegate OnComboPerformed;
    
    UPROPERTY()
    int32 ComboCounter = 0;

    UPROPERTY()
    int32 MaxComboCount = 3;

    UPROPERTY()
    bool bCanComboSave = false;

    UPROPERTY()
    bool bComboInputSaved = false;

    UPROPERTY()
    bool bIsInCancellableRecovery = false;

    // 콤보 전환 중인지 표시하는 플래그
    UPROPERTY()
    bool bIsTransitioningToNextCombo = false;
    
    // 어빌리티가 취소되면 몽타주 정지
    UPROPERTY()
    bool bStopMontageWhenAbilityCancelled;
    
#pragma endregion

#pragma region "Public Functions" //==========================================================

    UAbilityTask_PlayNormalAttackMontage(const FObjectInitializer& ObjectInitializer);

    // 태스크 생성 함수
    UFUNCTION(BlueprintCallable, Category = "Ability|Tasks", meta = (DisplayName = "PlayNormalAttackMontage",
        HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
    static UAbilityTask_PlayNormalAttackMontage* CreatePlayNormalAttackMontageProxy(
        UGameplayAbility* OwningAbility,
        FName TaskInstanceName,
        const TArray<TSoftObjectPtr<UAnimMontage>>& MontagesToPlay,
        float Rate = 1.0f,
        FName StartSection = NAME_None,
        float AnimRootMotionTranslationScale = 1.0f);

    // 태스크 활성화
    virtual void Activate() override;

    // 태스크 정리
    virtual void OnDestroy(bool AbilityEnded) override;

    // 외부 정지
    virtual void ExternalCancel() override;

    // 콤보 입력 처리 (원본의 InputPressed 로직)
    void CheckComboInputPreseed();

    // 다음 콤보 몽타주 재생
    void PlayNextAttackCombo();
    
#pragma endregion

protected:
#pragma region "Protected Variables" //=============================================================

    // 몽타주 배열 (콤보별)
    UPROPERTY()
    TArray<TSoftObjectPtr<UAnimMontage>> MontagesToPlay;
    
    // 현재 재생 중인 몽타주
    UPROPERTY()
    UAnimMontage* CurrentMontage;

    // 재생 속도
    UPROPERTY()
    float Rate;

    // 시작 섹션
    UPROPERTY()
    FName StartSectionName;

    // 루트 모션 스케일
    UPROPERTY()
    float AnimRootMotionTranslationScale;

    // 몽타주 델리게이트 핸들
    FOnMontageBlendingOutStarted BlendingOutDelegate;
    FOnMontageEnded MontageEndedDelegate;

    // 이벤트 핸들
    FDelegateHandle EnableComboInputHandle;
    FDelegateHandle ActionRecoveryEndHandle;
    FDelegateHandle ResetComboHandle;
    
#pragma endregion
    
#pragma region "Protected Functions" //=============================================================
    
    UFUNCTION()
    void PlayAttackMontage();
    
    UFUNCTION()
    void StopPlayingMontage();

    // 이벤트 핸들러
    UFUNCTION()
    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);

    UFUNCTION()
    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);
    
    UFUNCTION()
    void HandleEnableComboInputEvent(const FGameplayEventData& Payload);

    UFUNCTION()
    void HandleActionRecoveryEndEvent(const FGameplayEventData& Payload);

    UFUNCTION()
    void HandleResetComboEvent(const FGameplayEventData& Payload);

    // 이벤트 핸들 등록/해제
    void RegisterGameplayEventCallbacks();
    void UnregisterGameplayEventCallbacks();
    
#pragma endregion
};

================
File: ActionPractice\Public\Items\Weapon.h
================
#pragma once

#include "Public/Items/WeaponEnums.h"
#include "Public/Items/WeaponData.h"
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/StaticMeshComponent.h"
#include "Weapon.generated.h"

UCLASS()
class AWeapon : public AActor
{
	GENERATED_BODY()

public:
	AWeapon();
	virtual void Tick(float DeltaTime) override;
	virtual void BeginPlay() override;
	
	// ===== Info Getter =====
	FORCEINLINE FString GetWeaponName() const {return WeaponName;}
	FORCEINLINE WeaponEnums GetWeaponType() const {return WeaponType;}
	
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Weapon")
	const UWeaponDataAsset* GetWeaponData() const { return WeaponData.Get(); }
	const FBlockActionData* GetWeaponBlockData() const;
	const FAttackActionData* GetWeaponAttackDataByTag(FGameplayTag AttackTag) const;
	
	// 무기 사용 함수
	UFUNCTION(BlueprintCallable, Category = "Weapon")
	virtual void EquipWeapon();

	// ===== Combat Calculation Functions =====
	/*UFUNCTION(BlueprintPure, Category = "Combat")
	float CalculateTotalAttackPower(float PlayerStrength, float PlayerDexterity) const;

	UFUNCTION(BlueprintPure, Category = "Combat")
	bool CheckStatRequirements(float PlayerStrength, float PlayerDexterity) const;

	UFUNCTION(BlueprintPure, Category = "Combat")
	float GetAttackPowerPenalty(float PlayerStrength, float PlayerDexterity) const;*/

	// 콜리전 이벤트 함수들
	UFUNCTION()
	void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
	
protected:

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	UStaticMeshComponent* WeaponMesh;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Base Info")
	FString WeaponName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Base Info")
	WeaponEnums WeaponType;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Weapon Stats")
	TObjectPtr<UWeaponDataAsset> WeaponData;
};

================
File: ActionPractice\Public\Items\WeaponData.h
================
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"
#include "WeaponData.generated.h"

// UAnimMontage 클래스를 직접 포함하는 대신 전방 선언하여 컴파일 의존성을 낮춥니다.
class UAnimMontage;


//개별 공격 데이터
USTRUCT(BlueprintType)
struct FIndividualAttackData
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack")
	float DamageMultiplier = 1.0f;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack")
	float StaminaDamage = 10.0f;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack")
	float StaminaCost = 10.0f;
	// 필요에 따라 경직도, 사운드, 파티클 이펙트 등의 데이터를 여기에 추가할 수 있습니다.
};

//공격 유형 하나에 대한 정보
USTRUCT(BlueprintType)
struct FAttackActionData
{
	GENERATED_BODY()
	
	// 콤보별 몽타주 배열
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Animation")
	TArray<TSoftObjectPtr<UAnimMontage>> AttackMontages;

	// 콤보별 공격 데이터 (AttackMontages와 배열 크기가 같아야 함)
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack")
	TArray<FIndividualAttackData> ComboAttackData;
};

//방어 정보
USTRUCT(BlueprintType)
struct FBlockActionData
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Animation")
	TSoftObjectPtr<UAnimMontage> BlockMontage;

	//방어 데미지 감소량
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Block", meta = (ClampMin = "0.0", ClampMax = "100.0"))
	float DamageReduction;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Block")
	float StaminaCost = 10.0f;
};

UCLASS(BlueprintType)
class UWeaponDataAsset : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Base Stats")
	float BaseDamage = 100.0f;

	// 근력 보정 (A, B, C, D, E 등급을 숫자로 표현: 80=A, 60=B, 40=C, 20=D, 0=E)
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Base Stats", meta = (ClampMin = "0.0", ClampMax = "100.0"))
	float StrengthScaling;
	
	// 기량 보정
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Base Stats", meta = (ClampMin = "0.0", ClampMax = "100.0"))
	float DexterityScaling;
	
	//GameplayTag를 Key로 사용하여 각 공격 타입에 맞는 데이터를 쉽게 찾을 수 있습니다.
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack Definitions")
	TMap<FGameplayTag, FAttackActionData> AttackDataMap;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attack Definitions")
	FBlockActionData BlockData;
};

================
File: ActionPractice\Public\Items\WeaponEnums.h
================
#pragma once

#include "CoreMinimal.h"
#include "Engine/Engine.h"

UENUM(BlueprintType)
enum class WeaponEnums : uint8
{
	StraightSword UMETA(DisplayName = "StraightSword"), 
	GreatSword UMETA(DisplayName = "GreatSword"),
	Shield UMETA(DisplayName = "Shield"),
};

================
File: ActionPractice\Public\Notifies\AnimNotify_ActionRecoveryEnd.h
================
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_ActionRecoveryEnd.generated.h"

UCLASS(meta = (DisplayName = "Action Recovery End"))
class ACTIONPRACTICE_API UAnimNotify_ActionRecoveryEnd : public UAnimNotify
{
	GENERATED_BODY()

public:
	
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
	
	virtual FString GetNotifyName_Implementation() const override
	{
		return TEXT("Action Recovery End");
	}
};

================
File: ActionPractice\Public\Notifies\AnimNotify_EnableComboInput.h
================
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_EnableComboInput.generated.h"

/**
 * 
 */
UCLASS(meta = (DisplayName = "Enable Combo Input"))
class ACTIONPRACTICE_API UAnimNotify_EnableComboInput : public UAnimNotify
{
	GENERATED_BODY()

public:
	
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
	
	virtual FString GetNotifyName_Implementation() const override
	{
		return TEXT("Enable Combo Input");
	}
};

================
File: ActionPractice\Public\Notifies\AnimNotify_ResetCombo.h
================
#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_ResetCombo.generated.h"

UCLASS(meta = (DisplayName = "Reset Combo"))
class ACTIONPRACTICE_API UAnimNotify_ResetCombo : public UAnimNotify
{
	GENERATED_BODY()

public:
	
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
	
	virtual FString GetNotifyName_Implementation() const override
	{
		return TEXT("Reset Combo");
	}
};

================
File: ActionPractice\Variant_Combat\AnimNotify_CheckChargedAttack.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "AnimNotify_CheckChargedAttack.h"
#include "CombatAttacker.h"
#include "Components/SkeletalMeshComponent.h"

void UAnimNotify_CheckChargedAttack::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	// cast the owner to the attacker interface
	if (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))
	{
		// tell the actor to check for a charged attack loop
		AttackerInterface->CheckChargedAttack();
	}
}

FString UAnimNotify_CheckChargedAttack::GetNotifyName_Implementation() const
{
	return FString("Check Charged Attack");
}

================
File: ActionPractice\Variant_Combat\AnimNotify_CheckChargedAttack.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_CheckChargedAttack.generated.h"

/**
 *  AnimNotify to perform a charged attack hold check.
 */
UCLASS()
class UAnimNotify_CheckChargedAttack : public UAnimNotify
{
	GENERATED_BODY()
	
public:

	/** Perform the Anim Notify */
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;

	/** Get the notify name */
	virtual FString GetNotifyName_Implementation() const override;
};

================
File: ActionPractice\Variant_Combat\AnimNotify_CheckCombo.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "AnimNotify_CheckCombo.h"
#include "CombatAttacker.h"
#include "Components/SkeletalMeshComponent.h"

void UAnimNotify_CheckCombo::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	// cast the owner to the attacker interface
	if (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))
	{
		// tell the actor to check for combo string
		AttackerInterface->CheckCombo();
	}
}

FString UAnimNotify_CheckCombo::GetNotifyName_Implementation() const
{
	return FString("Check Combo String");
}

================
File: ActionPractice\Variant_Combat\AnimNotify_CheckCombo.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_CheckCombo.generated.h"

/**
 *  AnimNotify to perform a combo string check.
 */
UCLASS()
class UAnimNotify_CheckCombo : public UAnimNotify
{
	GENERATED_BODY()
	
public:

	/** Perform the Anim Notify */
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;

	/** Get the notify name */
	virtual FString GetNotifyName_Implementation() const override;
};

================
File: ActionPractice\Variant_Combat\AnimNotify_DoAttackTrace.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "AnimNotify_DoAttackTrace.h"
#include "CombatAttacker.h"
#include "Components/SkeletalMeshComponent.h"

void UAnimNotify_DoAttackTrace::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	// cast the owner to the attacker interface
	if (ICombatAttacker* AttackerInterface = Cast<ICombatAttacker>(MeshComp->GetOwner()))
	{
		AttackerInterface->DoAttackTrace(AttackBoneName);
	}
}

FString UAnimNotify_DoAttackTrace::GetNotifyName_Implementation() const
{
	return FString("Do Attack Trace");
}

================
File: ActionPractice\Variant_Combat\AnimNotify_DoAttackTrace.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_DoAttackTrace.generated.h"

/**
 *  AnimNotify to tell the actor to perform an attack trace check to look for targets to damage.
 */
UCLASS()
class UAnimNotify_DoAttackTrace : public UAnimNotify
{
	GENERATED_BODY()
	
protected:

	/** Source bone for the attack trace */
	UPROPERTY(EditAnywhere, Category="Attack")
	FName AttackBoneName;

public:

	/** Perform the Anim Notify */
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;

	/** Get the notify name */
	virtual FString GetNotifyName_Implementation() const override;
};

================
File: ActionPractice\Variant_Combat\CombatActivatable.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatActivatable.h"

================
File: ActionPractice\Variant_Combat\CombatActivatable.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "CombatActivatable.generated.h"

/**
 *  Interactable Interface
 *  Provides a context-agnostic way of activating, deactivating or toggling actors
 */
UINTERFACE(MinimalAPI, NotBlueprintable)
class UCombatActivatable : public UInterface
{
	GENERATED_BODY()
};

class ICombatActivatable
{
	GENERATED_BODY()

public:

	/** Toggles the Interactable Actor */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void ToggleInteraction(AActor* ActivationInstigator) = 0;

	/** Activates the Interactable Actor */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void ActivateInteraction(AActor* ActivationInstigator) = 0;

	/** Deactivates the Interactable Actor */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void DeactivateInteraction(AActor* ActivationInstigator) = 0;
};

================
File: ActionPractice\Variant_Combat\CombatActivationVolume.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatActivationVolume.h"
#include "Components/BoxComponent.h"
#include "GameFramework/Character.h"
#include "CombatActivatable.h"

ACombatActivationVolume::ACombatActivationVolume()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the box volume
	RootComponent = Box = CreateDefaultSubobject<UBoxComponent>(TEXT("Box"));
	check(Box);

	// set the box's extent
	Box->SetBoxExtent(FVector(500.0f, 500.0f, 500.0f));

	// set the default collision profile to overlap all dynamic
	Box->SetCollisionProfileName(FName("OverlapAllDynamic"));

	// bind the begin overlap 
	Box->OnComponentBeginOverlap.AddDynamic(this, &ACombatActivationVolume::OnOverlap);
}

void ACombatActivationVolume::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// has a Character entered the volume?
	ACharacter* PlayerCharacter = Cast<ACharacter>(OtherActor);

	if (PlayerCharacter)
	{
		// is the Character controlled by a player
		if (PlayerCharacter->IsPlayerControlled())
		{
			// process the actors to activate list
			for (AActor* CurrentActor : ActorsToActivate)
			{
				// is the referenced actor activatable?
				if(ICombatActivatable* Activatable = Cast<ICombatActivatable>(CurrentActor))
				{
					Activatable->ActivateInteraction(PlayerCharacter);
				}
			}
		}
	}

}

================
File: ActionPractice\Variant_Combat\CombatActivationVolume.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CombatActivationVolume.generated.h"

class UBoxComponent;

/**
 *  A simple volume that activates a list of actors when the player pawn enters.
 */
UCLASS()
class ACombatActivationVolume : public AActor
{
	GENERATED_BODY()

	/** Collision box volume */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Components, meta = (AllowPrivateAccess = "true"))
	UBoxComponent* Box;
	
protected:

	/** List of actors to activate when this volume is entered */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Activation Volume")
	TArray<AActor*> ActorsToActivate;

public:	
	
	/** Constructor */
	ACombatActivationVolume();

protected:

	/** Handles overlaps with the box volume */
	UFUNCTION()
	void OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

};

================
File: ActionPractice\Variant_Combat\CombatAttacker.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatAttacker.h"

================
File: ActionPractice\Variant_Combat\CombatAttacker.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "CombatAttacker.generated.h"

/**
 *  CombatAttacker Interface
 *  Provides common functionality to trigger attack animation events.
 */
UINTERFACE(MinimalAPI, NotBlueprintable)
class UCombatAttacker : public UInterface
{
	GENERATED_BODY()
};

class ICombatAttacker
{
	GENERATED_BODY()

public:

	/** Performs an attack's collision check. Usually called from a montage's AnimNotify */
	UFUNCTION(BlueprintCallable, Category="Attacker")
	virtual void DoAttackTrace(FName DamageSourceBone) = 0;

	/** Performs a combo attack's check to continue the string. Usually called from a montage's AnimNotify */
	UFUNCTION(BlueprintCallable, Category="Attacker")
	virtual void CheckCombo() = 0;

	/** Performs a charged attack's check to loop the charge animation. Usually called from a montage's AnimNotify */
	UFUNCTION(BlueprintCallable, Category="Attacker")
	virtual void CheckChargedAttack() = 0;
};

================
File: ActionPractice\Variant_Combat\CombatCharacter.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatCharacter.h"
#include "Components/CapsuleComponent.h"
#include "Components/WidgetComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "Camera/CameraComponent.h"
#include "EnhancedInputSubsystems.h"
#include "EnhancedInputComponent.h"
#include "CombatLifeBar.h"
#include "Engine/DamageEvents.h"
#include "TimerManager.h"
#include "Engine/LocalPlayer.h"
#include "CombatPlayerController.h"

DEFINE_LOG_CATEGORY(LogCombatCharacter);

ACombatCharacter::ACombatCharacter()
{
	PrimaryActorTick.bCanEverTick = true;

	// bind the attack montage ended delegate
	OnAttackMontageEnded.BindUObject(this, &ACombatCharacter::AttackMontageEnded);

	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);

	// Configure character movement
	GetCharacterMovement()->MaxWalkSpeed = 400.0f;

	// create the camera boom
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);

	CameraBoom->TargetArmLength = DefaultCameraDistance;
	CameraBoom->bUsePawnControlRotation = true;
	CameraBoom->bEnableCameraLag = true;
	CameraBoom->bEnableCameraRotationLag = true;

	// create the orbiting camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
	FollowCamera->bUsePawnControlRotation = false;

	// create the life bar widget component
	LifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT("LifeBar"));
	LifeBar->SetupAttachment(RootComponent);

	// set the player tag
	Tags.Add(FName("Player"));
}

void ACombatCharacter::Move(const FInputActionValue& Value)
{
	// input is a Vector2D
	FVector2D MovementVector = Value.Get<FVector2D>();

	// route the input
	DoMove(MovementVector.X, MovementVector.Y);
}

void ACombatCharacter::Look(const FInputActionValue& Value)
{
	FVector2D LookAxisVector = Value.Get<FVector2D>();

	// route the input
	DoLook(LookAxisVector.X, LookAxisVector.Y);
}

void ACombatCharacter::ComboAttackPressed()
{
	// route the input
	DoComboAttackStart();
}

void ACombatCharacter::ChargedAttackPressed()
{
	// route the input
	DoChargedAttackStart();
}

void ACombatCharacter::ChargedAttackReleased()
{
	// route the input
	DoChargedAttackEnd();
}

void ACombatCharacter::DoMove(float Right, float Forward)
{
	if (GetController() != nullptr)
	{
		// find out which way is forward
		const FRotator Rotation = GetController()->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get forward vector
		const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);

		// get right vector 
		const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

		// add movement 
		AddMovementInput(ForwardDirection, Forward);
		AddMovementInput(RightDirection, Right);
	}
}

void ACombatCharacter::DoLook(float Yaw, float Pitch)
{
	if (GetController() != nullptr)
	{
		// add yaw and pitch input to controller
		AddControllerYawInput(Yaw);
		AddControllerPitchInput(Pitch);
	}
}

void ACombatCharacter::DoComboAttackStart()
{
	// are we already playing an attack animation?
	if (bIsAttacking)
	{
		// cache the input time so we can check it later
		CachedAttackInputTime = GetWorld()->GetTimeSeconds();

		return;
	}

	// perform a combo attack
	ComboAttack();
}

void ACombatCharacter::DoComboAttackEnd()
{
	// stub
}

void ACombatCharacter::DoChargedAttackStart()
{
	// raise the charging attack flag
	bIsChargingAttack = true;

	if (bIsAttacking)
	{
		// cache the input time so we can check it later
		CachedAttackInputTime = GetWorld()->GetTimeSeconds();

		return;
	}

	ChargedAttack();
}

void ACombatCharacter::DoChargedAttackEnd()
{
	// lower the charging attack flag
	bIsChargingAttack = false;

	// if we've done the charge loop at least once, release the charged attack right away
	if (bHasLoopedChargedAttack)
	{
		CheckChargedAttack();
	}
}

void ACombatCharacter::ResetHP()
{
	// reset the current HP total
	CurrentHP = MaxHP;

	// update the life bar
	LifeBarWidget->SetLifePercentage(1.0f);
}

void ACombatCharacter::ComboAttack()
{
	// raise the attacking flag
	bIsAttacking = true;

	// reset the combo count
	ComboCount = 0;

	// play the attack montage
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		const float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);

		// subscribe to montage completed and interrupted events
		if (MontageLength > 0.0f)
		{
			// set the end delegate for the montage
			AnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);
		}
	}

}

void ACombatCharacter::ChargedAttack()
{
	// raise the attacking flag
	bIsAttacking = true;

	// reset the charge loop flag
	bHasLoopedChargedAttack = false;

	// play the charged attack montage
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		const float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);

		// subscribe to montage completed and interrupted events
		if (MontageLength > 0.0f)
		{
			// set the end delegate for the montage
			AnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);
		}
	}
}

void ACombatCharacter::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	// reset the attacking flag
	bIsAttacking = false;

	// check if we have a non-stale cached input
	if (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= AttackInputCacheTimeTolerance)
	{
		// are we holding the charged attack button?
		if (bIsChargingAttack)
		{
			// do a charged attack
			ChargedAttack();
		}
		else
		{
			// do a regular attack
			ComboAttack();
		}
	}
}

void ACombatCharacter::DoAttackTrace(FName DamageSourceBone)
{
	// sweep for objects in front of the character to be hit by the attack
	TArray<FHitResult> OutHits;

	// start at the provided socket location, sweep forward
	const FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);
	const FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);

	// check for pawn and world dynamic collision object types
	FCollisionObjectQueryParams ObjectParams;
	ObjectParams.AddObjectTypesToQuery(ECC_Pawn);
	ObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);

	// use a sphere shape for the sweep
	FCollisionShape CollisionShape;
	CollisionShape.SetSphere(MeleeTraceRadius);

	// ignore self
	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(this);

	if (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))
	{
		// iterate over each object hit
		for (const FHitResult& CurrentHit : OutHits)
		{
			// check if we've hit a damageable actor
			ICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());

			if (Damageable)
			{
				// knock upwards and away from the impact normal
				const FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);

				// pass the damage event to the actor
				Damageable->ApplyDamage(MeleeDamage, this, CurrentHit.ImpactPoint, Impulse);

				// call the BP handler to play effects, etc.
				DealtDamage(MeleeDamage, CurrentHit.ImpactPoint);
			}
		}
	}
}

void ACombatCharacter::CheckCombo()
{
	// are we playing a non-charge attack animation?
	if (bIsAttacking && !bIsChargingAttack)
	{
		// is the last attack input not stale?
		if (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= ComboInputCacheTimeTolerance)
		{
			// consume the attack input so we don't accidentally trigger it twice
			CachedAttackInputTime = 0.0f;

			// increase the combo counter
			++ComboCount;

			// do we still have a combo section to play?
			if (ComboCount < ComboSectionNames.Num())
			{
				// jump to the next combo section
				if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
				{
					AnimInstance->Montage_JumpToSection(ComboSectionNames[ComboCount], ComboAttackMontage);
				}
			}
		}
	}
}

void ACombatCharacter::CheckChargedAttack()
{
	// raise the looped charged attack flag
	bHasLoopedChargedAttack = true;

	// jump to either the loop or the attack section depending on whether we're still holding the charge button
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		AnimInstance->Montage_JumpToSection(bIsChargingAttack ? ChargeLoopSection : ChargeAttackSection, ChargedAttackMontage);
	}
}

void ACombatCharacter::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)
{
	// pass the damage event to the actor
	FDamageEvent DamageEvent;
	const float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);

	// only process knockback and effects if we received nonzero damage
	if (ActualDamage > 0.0f)
	{
		// apply the knockback impulse
		GetCharacterMovement()->AddImpulse(DamageImpulse, true);

		// is the character ragdolling?
		if (GetMesh()->IsSimulatingPhysics())
		{
			// apply an impulse to the ragdoll
			GetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);
		}

		// pass control to BP to play effects, etc.
		ReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());
	}

}

void ACombatCharacter::HandleDeath()
{
	// disable movement while we're dead
	GetCharacterMovement()->DisableMovement();

	// enable full ragdoll physics
	GetMesh()->SetSimulatePhysics(true);

	// hide the life bar
	LifeBar->SetHiddenInGame(true);

	// pull back the camera
	GetCameraBoom()->TargetArmLength = DeathCameraDistance;

	// schedule respawning
	GetWorld()->GetTimerManager().SetTimer(RespawnTimer, this, &ACombatCharacter::RespawnCharacter, RespawnTime, false);
}

void ACombatCharacter::ApplyHealing(float Healing, AActor* Healer)
{
	// stub
}

void ACombatCharacter::RespawnCharacter()
{
	// destroy the character and let it be respawned by the Player Controller
	Destroy();
}

float ACombatCharacter::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)
{
	// only process damage if the character is still alive
	if (CurrentHP <= 0.0f)
	{
		return 0.0f;
	}

	// reduce the current HP
	CurrentHP -= Damage;

	// have we run out of HP?
	if (CurrentHP <= 0.0f)
	{
		// die
		HandleDeath();
	}
	else
	{
		// update the life bar
		LifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);

		// enable partial ragdoll physics, but keep the pelvis vertical
		GetMesh()->SetPhysicsBlendWeight(0.5f);
		GetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);
	}

	// return the received damage amount
	return Damage;
}

void ACombatCharacter::Landed(const FHitResult& Hit)
{
	Super::Landed(Hit);

	// is the character still alive?
	if (CurrentHP >= 0.0f)
	{
		// disable ragdoll physics
		GetMesh()->SetPhysicsBlendWeight(0.0f);
	}
}

void ACombatCharacter::BeginPlay()
{
	Super::BeginPlay();

	// get the life bar from the widget component
	LifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());
	check(LifeBarWidget);

	// initialize the camera
	GetCameraBoom()->TargetArmLength = DefaultCameraDistance;

	// save the relative transform for the mesh so we can reset the ragdoll later
	MeshStartingTransform = GetMesh()->GetRelativeTransform();

	// set the life bar color
	LifeBarWidget->SetBarColor(LifeBarColor);

	// reset HP to maximum
	ResetHP();
}

void ACombatCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the respawn timer
	GetWorld()->GetTimerManager().ClearTimer(RespawnTimer);
}

void ACombatCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Set up action bindings
	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
	{
		// Moving
		EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Move);

		// Looking
		EnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);
		EnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);

		// Combo Attack
		EnhancedInputComponent->BindAction(ComboAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ComboAttackPressed);

		// Charged Attack
		EnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ChargedAttackPressed);
		EnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Completed, this, &ACombatCharacter::ChargedAttackReleased);
	}
}

void ACombatCharacter::NotifyControllerChanged()
{
	Super::NotifyControllerChanged();

	// update the respawn transform on the Player Controller
	if (ACombatPlayerController* PC = Cast<ACombatPlayerController>(GetController()))
	{
		PC->SetRespawnTransform(GetActorTransform());
	}
}

================
File: ActionPractice\Variant_Combat\CombatCharacter.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "CombatAttacker.h"
#include "CombatDamageable.h"
#include "Animation/AnimInstance.h"
#include "CombatCharacter.generated.h"

class USpringArmComponent;
class UCameraComponent;
class UInputAction;
struct FInputActionValue;
class UCombatLifeBar;
class UWidgetComponent;

DECLARE_LOG_CATEGORY_EXTERN(LogCombatCharacter, Log, All);

/**
 *  An enhanced Third Person Character with melee combat capabilities:
 *  - Combo attack string
 *  - Press and hold charged attack
 *  - Damage dealing and reaction
 *  - Death
 *  - Respawning
 */
UCLASS(abstract)
class ACombatCharacter : public ACharacter, public ICombatAttacker, public ICombatDamageable
{
	GENERATED_BODY()

	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	USpringArmComponent* CameraBoom;

	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	UCameraComponent* FollowCamera;

	/** Life bar widget component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = UI, meta = (AllowPrivateAccess = "true"))
	UWidgetComponent* LifeBar;
	
protected:

	/** Jump Input Action */
	UPROPERTY(EditAnywhere, Category ="Input")
	UInputAction* JumpAction;

	/** Move Input Action */
	UPROPERTY(EditAnywhere, Category ="Input")
	UInputAction* MoveAction;

	/** Look Input Action */
	UPROPERTY(EditAnywhere, Category ="Input")
	UInputAction* LookAction;

	/** Mouse Look Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* MouseLookAction;

	/** Combo Attack Input Action */
	UPROPERTY(EditAnywhere, Category ="Input")
	UInputAction* ComboAttackAction;

	/** Charged Attack Input Action */
	UPROPERTY(EditAnywhere, Category ="Input")
	UInputAction* ChargedAttackAction;

	/** Max amount of HP the character will have on respawn */
	UPROPERTY(EditAnywhere, Category="Damage", meta = (ClampMin = 0, ClampMax = 100))
	float MaxHP = 5.0f;

	/** Current amount of HP the character has */
	UPROPERTY(VisibleAnywhere, Category="Damage")
	float CurrentHP = 0.0f;

	/** Life bar widget fill color */
	UPROPERTY(EditAnywhere, Category="Damage")
	FLinearColor LifeBarColor;

	/** Name of the pelvis bone, for damage ragdoll physics */
	UPROPERTY(EditAnywhere, Category="Damage")
	FName PelvisBoneName;

	/** Pointer to the life bar widget */
	UPROPERTY(EditAnywhere, Category="Damage")
	TObjectPtr<UCombatLifeBar> LifeBarWidget;

	/** Max amount of time that may elapse for a non-combo attack input to not be considered stale */
	UPROPERTY(EditAnywhere, Category="Melee Attack", meta = (ClampMin = 0, ClampMax = 5))
	float AttackInputCacheTimeTolerance = 1.0f;

	/** Time at which an attack button was last pressed */
	float CachedAttackInputTime = 0.0f;

	/** If true, the character is currently playing an attack animation */
	bool bIsAttacking = false;

	/** Distance ahead of the character that melee attack sphere collision traces will extend */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Trace", meta=(ClampMin=0, ClampMax=500, Units="cm"))
	float MeleeTraceDistance = 75.0f;

	/** Radius of the sphere trace for melee attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Trace", meta = (ClampMin = 0, ClampMax = 200, Units = "cm"))
	float MeleeTraceRadius = 75.0f;

	/** Amount of damage a melee attack will deal */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 100))
	float MeleeDamage = 1.0f;

	/** Amount of knockback impulse a melee attack will apply */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm/s"))
	float MeleeKnockbackImpulse = 250.0f;

	/** Amount of upwards impulse a melee attack will apply */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm/s"))
	float MeleeLaunchImpulse = 300.0f;

	/** AnimMontage that will play for combo attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Combo")
	UAnimMontage* ComboAttackMontage;

	/** Names of the AnimMontage sections that correspond to each stage of the combo attack */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Combo")
	TArray<FName> ComboSectionNames;

	/** Max amount of time that may elapse for a combo attack input to not be considered stale */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Combo", meta = (ClampMin = 0, ClampMax = 5))
	float ComboInputCacheTimeTolerance = 0.45f;

	/** Index of the current stage of the melee attack combo */
	int32 ComboCount = 0;

	/** AnimMontage that will play for charged attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	UAnimMontage* ChargedAttackMontage;

	/** Name of the AnimMontage section that corresponds to the charge loop */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	FName ChargeLoopSection;

	/** Name of the AnimMontage section that corresponds to the attack */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	FName ChargeAttackSection;

	/** Flag that determines if the player is currently holding the charged attack input */
	bool bIsChargingAttack = false;
	
	/** If true, the charged attack hold check has been tested at least once */
	bool bHasLoopedChargedAttack = false;

	/** Camera boom length while the character is dead */
	UPROPERTY(EditAnywhere, Category="Camera", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm"))
	float DeathCameraDistance = 400.0f;

	/** Camera boom length when the character respawns */
	UPROPERTY(EditAnywhere, Category="Camera", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm"))
	float DefaultCameraDistance = 100.0f;

	/** Time to wait before respawning the character */
	UPROPERTY(EditAnywhere, Category="Respawn", meta = (ClampMin = 0, ClampMax = 10))
	float RespawnTime = 3.0f;

	/** Attack montage ended delegate */
	FOnMontageEnded OnAttackMontageEnded;

	/** Character respawn timer */
	FTimerHandle RespawnTimer;

	/** Copy of the mesh's transform so we can reset it after ragdoll animations */
	FTransform MeshStartingTransform;

public:
	
	/** Constructor */
	ACombatCharacter();

protected:

	/** Called for movement input */
	void Move(const FInputActionValue& Value);

	/** Called for looking input */
	void Look(const FInputActionValue& Value);

	/** Called for combo attack input */
	void ComboAttackPressed();

	/** Called for combo attack input pressed */
	void ChargedAttackPressed();

	/** Called for combo attack input released */
	void ChargedAttackReleased();

public:

	/** Handles move inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoMove(float Right, float Forward);

	/** Handles look inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoLook(float Yaw, float Pitch);

	/** Handles combo attack pressed from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoComboAttackStart();

	/** Handles combo attack released from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoComboAttackEnd();

	/** Handles charged attack pressed from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoChargedAttackStart();

	/** Handles charged attack released from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoChargedAttackEnd();

protected:

	/** Resets the character's current HP to maximum */
	void ResetHP();

	/** Performs a combo attack */
	void ComboAttack();

	/** Performs a charged attack */
	void ChargedAttack();

	/** Called from a delegate when the attack montage ends */
	void AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted);

	
public:

	// ~begin CombatAttacker interface

	/** Performs the collision check for an attack */
	virtual void DoAttackTrace(FName DamageSourceBone) override;

	/** Performs the combo string check */
	virtual void CheckCombo() override;

	/** Performs the charged attack hold check */
	virtual void CheckChargedAttack() override;

	// ~end CombatAttacker interface

	// ~begin CombatDamageable interface

	/** Handles damage and knockback events */
	virtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;

	/** Handles death events */
	virtual void HandleDeath() override;

	/** Handles healing events */
	virtual void ApplyHealing(float Healing, AActor* Healer) override;

	// ~end CombatDamageable interface

	/** Called from the respawn timer to destroy and re-create the character */
	void RespawnCharacter();

public:

	/** Overrides the default TakeDamage functionality */
	virtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) override;

	/** Overrides landing to reset damage ragdoll physics */
	virtual void Landed(const FHitResult& Hit) override;

protected:

	/** Blueprint handler to play damage dealt effects */
	UFUNCTION(BlueprintImplementableEvent, Category="Combat")
	void DealtDamage(float Damage, const FVector& ImpactPoint);

	/** Blueprint handler to play damage received effects */
	UFUNCTION(BlueprintImplementableEvent, Category="Combat")
	void ReceivedDamage(float Damage, const FVector& ImpactPoint, const FVector& DamageDirection);

protected:

	/** Initialization */
	virtual void BeginPlay() override;

	/** Cleanup */
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	/** Handles input bindings */
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	/** Handles possessed initialization */
	virtual void NotifyControllerChanged() override;

public:

	/** Returns CameraBoom subobject **/
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }

	/** Returns FollowCamera subobject **/
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }
};

================
File: ActionPractice\Variant_Combat\CombatCheckpointVolume.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatCheckpointVolume.h"
#include "CombatCharacter.h"
#include "CombatPlayerController.h"

ACombatCheckpointVolume::ACombatCheckpointVolume()
{
	// create the box volume
	RootComponent = Box = CreateDefaultSubobject<UBoxComponent>(TEXT("Box"));
	check(Box);

	// set the box's extent
	Box->SetBoxExtent(FVector(500.0f, 500.0f, 500.0f));

	// set the default collision profile to overlap all dynamic
	Box->SetCollisionProfileName(FName("OverlapAllDynamic"));

	// bind the begin overlap 
	Box->OnComponentBeginOverlap.AddDynamic(this, &ACombatCheckpointVolume::OnOverlap);
}

void ACombatCheckpointVolume::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// ensure we use this only once
	if (bCheckpointUsed)
	{
		return;
	}
		
	// has the player entered this volume?
	ACombatCharacter* PlayerCharacter = Cast<ACombatCharacter>(OtherActor);

	if (PlayerCharacter)
	{
		if (ACombatPlayerController* PC = Cast<ACombatPlayerController>(PlayerCharacter->GetController()))
		{
			// raise the checkpoint used flag
			bCheckpointUsed = true;

			// update the player's respawn checkpoint
			PC->SetRespawnTransform(PlayerCharacter->GetActorTransform());
		}

	}
}

================
File: ActionPractice\Variant_Combat\CombatCheckpointVolume.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Components/BoxComponent.h"
#include "CombatCheckpointVolume.generated.h"

UCLASS(abstract)
class ACombatCheckpointVolume : public AActor
{
	GENERATED_BODY()
	
	/** Collision box volume */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Components, meta = (AllowPrivateAccess = "true"))
	UBoxComponent* Box;

public:	
	
	/** Constructor */
	ACombatCheckpointVolume();

protected:

	/** Set to true after use to avoid accidentally resetting the checkpoint */
	bool bCheckpointUsed = false;

	/** Handles overlaps with the box volume */
	UFUNCTION()
	void OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
};

================
File: ActionPractice\Variant_Combat\CombatDamageable.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatDamageable.h"

// Add default functionality here for any ICombatDamageable functions that are not pure virtual.

================
File: ActionPractice\Variant_Combat\CombatDamageable.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "CombatDamageable.generated.h"

/**
 *  CombatDamageable interface
 *  Provides functionality to handle damage, healing, knockback and death
 */
UINTERFACE(MinimalAPI, NotBlueprintable)
class UCombatDamageable : public UInterface
{
	GENERATED_BODY()
};

class ICombatDamageable
{
	GENERATED_BODY()

public:

	/** Handles damage and knockback events */
	UFUNCTION(BlueprintCallable, Category="Damageable")
	virtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) = 0;

	/** Handles death events */
	UFUNCTION(BlueprintCallable, Category="Damageable")
	virtual void HandleDeath() = 0;

	/** Handles healing events */
	UFUNCTION(BlueprintCallable, Category="Damageable")
	virtual void ApplyHealing(float Healing, AActor* Healer) = 0;
};

================
File: ActionPractice\Variant_Combat\CombatDamageableBox.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatDamageableBox.h"
#include "Components/StaticMeshComponent.h"
#include "TimerManager.h"
#include "Engine/World.h"

ACombatDamageableBox::ACombatDamageableBox()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the mesh
	RootComponent = Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));

	// set the collision properties
	Mesh->SetCollisionProfileName(FName("BlockAllDynamic"));

	// enable physics
	Mesh->SetSimulatePhysics(true);

	// disable navigation relevance so boxes don't affect NavMesh generation
	Mesh->bNavigationRelevant = false;
}

void ACombatDamageableBox::RemoveFromLevel()
{
	// destroy this actor
	Destroy();
}

void ACombatDamageableBox::EndPlay(EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the death timer
	GetWorld()->GetTimerManager().ClearTimer(DeathTimer);
}

void ACombatDamageableBox::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)
{
	// only process damage if we still have HP
	if (CurrentHP > 0.0f)
	{
		// apply the damage
		CurrentHP -= Damage;

		// are we dead?
		if (CurrentHP <= 0.0f)
		{
			HandleDeath();
		}

		// apply a physics impulse to the box, ignoring its mass
		Mesh->AddImpulseAtLocation(DamageImpulse * Mesh->GetMass(), DamageLocation);

		// call the BP handler to play effects, etc.
		OnBoxDamaged(DamageLocation, DamageImpulse);
	}
}

void ACombatDamageableBox::HandleDeath()
{
	// change the collision object type to Visibility so we ignore most interactions but still retain physics collisions
	Mesh->SetCollisionObjectType(ECC_Visibility);

	// call the BP handler to play effects, etc.
	OnBoxDestroyed();

	// set up the death cleanup timer
	GetWorld()->GetTimerManager().SetTimer(DeathTimer, this, &ACombatDamageableBox::RemoveFromLevel, DeathDelayTime);
}

void ACombatDamageableBox::ApplyHealing(float Healing, AActor* Healer)
{
	// stub
}

================
File: ActionPractice\Variant_Combat\CombatDamageableBox.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CombatDamageable.h"
#include "CombatDamageableBox.generated.h"

/**
 *  A simple physics box that reacts to damage through the ICombatDamageable interface
 */
UCLASS(abstract)
class ACombatDamageableBox : public AActor, public ICombatDamageable
{
	GENERATED_BODY()
	
	/** Damageable box mesh */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Mesh;

public:	

	/** Constructor */
	ACombatDamageableBox();

protected:

	/** Amount of HP this box starts with. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Damage")
	float CurrentHP = 3.0f;

	/** Time to wait before we remove this box from the level. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Damage")
	float DeathDelayTime = 6.0f;

	FTimerHandle DeathTimer;

	/** Blueprint damage handler for effect playback */
	UFUNCTION(BlueprintImplementableEvent, Category="Damage")
	void OnBoxDamaged(const FVector& DamageLocation, const FVector& DamageImpulse);

	/** Blueprint destruction handler for effect playback */
	UFUNCTION(BlueprintImplementableEvent, Category="Damage")
	void OnBoxDestroyed();

	/** Timer callback to remove the box from the level after it dies */
	void RemoveFromLevel();

public:

	/** EndPlay cleanup */
	void EndPlay(EEndPlayReason::Type EndPlayReason) override;

	// ~Begin CombatDamageable interface

	/** Handles damage and knockback events */
	virtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;

	/** Handles death events */
	virtual void HandleDeath() override;

	/** Handles healing events */
	virtual void ApplyHealing(float Healing, AActor* Healer) override;

	// ~End CombatDamageable interface
};

================
File: ActionPractice\Variant_Combat\CombatDummy.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Variant_Combat/CombatDummy.h"
#include "Components/SceneComponent.h"
#include "Components/StaticMeshComponent.h"
#include "PhysicsEngine/PhysicsConstraintComponent.h"

ACombatDummy::ACombatDummy()
{
 	PrimaryActorTick.bCanEverTick = true;

	// create the root
	Root = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
	SetRootComponent(Root);

	// create the base plate
	BasePlate = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Base Plate"));
	BasePlate->SetupAttachment(RootComponent);

	// create the dummy
	Dummy = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Dummy"));
	Dummy->SetupAttachment(RootComponent);

	Dummy->SetSimulatePhysics(true);

	// create the physics constraint
	PhysicsConstraint = CreateDefaultSubobject<UPhysicsConstraintComponent>(TEXT("Physics Constraint"));
	PhysicsConstraint->SetupAttachment(RootComponent);

	PhysicsConstraint->SetConstrainedComponents(BasePlate, NAME_None, Dummy, NAME_None);
}

void ACombatDummy::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)
{
	// apply impulse to the dummy
	Dummy->AddImpulseAtLocation(DamageImpulse, DamageLocation);

	// call the BP handler
	BP_OnDummyDamaged(DamageLocation, DamageImpulse.GetSafeNormal());
}

void ACombatDummy::HandleDeath()
{
	// unused
}

void ACombatDummy::ApplyHealing(float Healing, AActor* Healer)
{
	// unused
}

================
File: ActionPractice\Variant_Combat\CombatDummy.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CombatDamageable.h"
#include "CombatDummy.generated.h"

class UStaticMeshComponent;
class UPhysicsConstraintComponent;

/**
 *  A simple invincible combat training dummy
 */
UCLASS(abstract)
class ACombatDummy : public AActor, public ICombatDamageable
{
	GENERATED_BODY()
	
	/** Root component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	USceneComponent* Root;

	/** Static base plate */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* BasePlate;

	/** Physics enabled dummy mesh */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Dummy;

	/** Physics constraint holding the dummy and base plate together */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	UPhysicsConstraintComponent* PhysicsConstraint;

public:	
	
	/** Constructor */
	ACombatDummy();

	// ~Begin CombatDamageable interface

		/** Handles damage and knockback events */
	virtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;

	/** Handles death events */
	virtual void HandleDeath() override;

	/** Handles healing events */
	virtual void ApplyHealing(float Healing, AActor* Healer) override;

	// ~End CombatDamageable interface

protected:

	/** Blueprint handle to apply damage effects */
	UFUNCTION(BlueprintImplementableEvent, Category="Combat", meta=(DisplayName = "On Dummy Damaged"))
	void BP_OnDummyDamaged(const FVector& Location, const FVector& Direction);
};

================
File: ActionPractice\Variant_Combat\CombatGameMode.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Variant_Combat/CombatGameMode.h"

ACombatGameMode::ACombatGameMode()
{

}

================
File: ActionPractice\Variant_Combat\CombatGameMode.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "CombatGameMode.generated.h"

/**
 *  Simple GameMode for a third person combat game
 */
UCLASS(abstract)
class ACombatGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
public:

	ACombatGameMode();
};

================
File: ActionPractice\Variant_Combat\CombatLavaFloor.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatLavaFloor.h"
#include "CombatDamageable.h"
#include "Components/StaticMeshComponent.h"

ACombatLavaFloor::ACombatLavaFloor()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the mesh
	RootComponent = Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));

	// bind the hit handler
	Mesh->OnComponentHit.AddDynamic(this, &ACombatLavaFloor::OnFloorHit);
}

void ACombatLavaFloor::OnFloorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
	// check if the hit actor is damageable by casting to the interface
	if (ICombatDamageable* Damageable = Cast<ICombatDamageable>(OtherActor))
	{
		// damage the actor
		Damageable->ApplyDamage(Damage, this, Hit.ImpactPoint, FVector::ZeroVector);
	}
}

================
File: ActionPractice\Variant_Combat\CombatLavaFloor.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CombatLavaFloor.generated.h"

class UStaticMeshComponent;
class UPrimitiveComponent;

/**
 *  A basic actor that applies damage on contact through the ICombatDamageable interface. 
 */
UCLASS(abstract)
class ACombatLavaFloor : public AActor
{
	GENERATED_BODY()
	
	/** Floor mesh */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Mesh;

protected:

	/** Amount of damage to deal on contact */
	UPROPERTY(EditAnywhere, Category="Damage")
	float Damage = 10000.0f;

public:	

	/** Constructor */
	ACombatLavaFloor();

protected:

	/** Blocking hit handler */
	UFUNCTION()
	void OnFloorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
};

================
File: ActionPractice\Variant_Combat\CombatLifeBar.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatLifeBar.h"

================
File: ActionPractice\Variant_Combat\CombatLifeBar.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "CombatLifeBar.generated.h"

/**
 *  A basic life bar user widget.
 */
UCLASS(abstract)
class UCombatLifeBar : public UUserWidget
{
	GENERATED_BODY()

public:

	/** Sets the life bar to the provided 0-1 percentage value*/
	UFUNCTION(BlueprintImplementableEvent, Category="LifeBar")
	void SetLifePercentage(float Percent);

	// Sets the life bar fill color
	UFUNCTION(BlueprintImplementableEvent, Category="LifeBar")
	void SetBarColor(FLinearColor Color);
};

================
File: ActionPractice\Variant_Combat\CombatPlayerController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Variant_Combat/CombatPlayerController.h"
#include "EnhancedInputSubsystems.h"
#include "InputMappingContext.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/PlayerStart.h"
#include "CombatCharacter.h"
#include "Engine/LocalPlayer.h"
#include "Engine/World.h"

void ACombatPlayerController::SetupInputComponent()
{
	// add the input mapping context
	if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))
	{
		for (UInputMappingContext* CurrentContext : DefaultMappingContexts)
		{
			Subsystem->AddMappingContext(CurrentContext, 0);
		}
	}
}

void ACombatPlayerController::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);

	// subscribe to the pawn's OnDestroyed delegate
	InPawn->OnDestroyed.AddDynamic(this, &ACombatPlayerController::OnPawnDestroyed);
}

void ACombatPlayerController::SetRespawnTransform(const FTransform& NewRespawn)
{
	// save the new respawn transform
	RespawnTransform = NewRespawn;
}

void ACombatPlayerController::OnPawnDestroyed(AActor* DestroyedActor)
{
	// spawn a new character at the respawn transform
	if (ACombatCharacter* RespawnedCharacter = GetWorld()->SpawnActor<ACombatCharacter>(CharacterClass, RespawnTransform))
	{
		// possess the character
		Possess(RespawnedCharacter);
	}
}

================
File: ActionPractice\Variant_Combat\CombatPlayerController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "CombatPlayerController.generated.h"

class UInputMappingContext;
class ACombatCharacter;

/**
 *  Simple Player Controller for a third person combat game
 *  Manages input mappings
 *  Respawns the player character at the checkpoint when it's destroyed
 */
UCLASS(abstract)
class ACombatPlayerController : public APlayerController
{
	GENERATED_BODY()
	
protected:

	/** Input mapping context for this player */
	UPROPERTY(EditAnywhere, Category="Input")
	TArray<UInputMappingContext*> DefaultMappingContexts;

	/** Character class to respawn when the possessed pawn is destroyed */
	UPROPERTY(EditAnywhere, Category="Respawn")
	TSubclassOf<ACombatCharacter> CharacterClass;

	/** Transform to respawn the character at. Can be set to create checkpoints */
	FTransform RespawnTransform;

protected:

	/** Initialize input bindings */
	virtual void SetupInputComponent() override;

	/** Pawn initialization */
	virtual void OnPossess(APawn* InPawn) override;

public:

	/** Updates the character respawn transform */
	void SetRespawnTransform(const FTransform& NewRespawn);

protected:

	/** Called if the possessed pawn is destroyed */
	UFUNCTION()
	void OnPawnDestroyed(AActor* DestroyedActor);

};

================
File: ActionPractice\Variant_Combat\AI\CombatAIController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatAIController.h"
#include "Components/StateTreeAIComponent.h"

ACombatAIController::ACombatAIController()
{
	// create the StateTree AI Component
	StateTreeAI = CreateDefaultSubobject<UStateTreeAIComponent>(TEXT("StateTreeAI"));
	check(StateTreeAI);

	// ensure we start the StateTree when we possess the pawn
	bStartAILogicOnPossess = true;

	// ensure we're attached to the possessed character.
	// this is necessary for EnvQueries to work correctly
	bAttachToPawn = true;
}

================
File: ActionPractice\Variant_Combat\AI\CombatAIController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "AIController.h"
#include "CombatAIController.generated.h"

class UStateTreeAIComponent;

/**
 *	A basic AI Controller capable of running StateTree
 */
UCLASS(abstract)
class ACombatAIController : public AAIController
{
	GENERATED_BODY()

	/** StateTree Component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI", meta = (AllowPrivateAccess = "true"))
	UStateTreeAIComponent* StateTreeAI;

public:

	/** Constructor */
	ACombatAIController();
};

================
File: ActionPractice\Variant_Combat\AI\CombatEnemy.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatEnemy.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "CombatAIController.h"
#include "Components/WidgetComponent.h"
#include "Engine/DamageEvents.h"
#include "CombatLifeBar.h"
#include "TimerManager.h"
#include "Components/SkeletalMeshComponent.h"
#include "Animation/AnimInstance.h"

ACombatEnemy::ACombatEnemy()
{
	PrimaryActorTick.bCanEverTick = true;

	// bind the attack montage ended delegate
	OnAttackMontageEnded.BindUObject(this, &ACombatEnemy::AttackMontageEnded);

	// set the AI Controller class by default
	AIControllerClass = ACombatAIController::StaticClass();

	// use an AI Controller regardless of whether we're placed or spawned
	AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;

	// ignore the controller's yaw rotation
	bUseControllerRotationYaw = false;

	// create the life bar
	LifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT("LifeBar"));
	LifeBar->SetupAttachment(RootComponent);

	// set the collision capsule size
	GetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);

	// set the character movement properties
	GetCharacterMovement()->bUseControllerDesiredRotation = true;

	// reset HP to maximum
	CurrentHP = MaxHP;
}

void ACombatEnemy::DoAIComboAttack()
{
	// ignore if we're already playing an attack animation
	if (bIsAttacking)
	{
		return;
	}

	// raise the attacking flag
	bIsAttacking = true;

	// choose how many times we're going to attack
	TargetComboCount = FMath::RandRange(1, ComboSectionNames.Num() - 1);

	// reset the attack counter
	CurrentComboAttack = 0;

	// play the attack montage
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		const float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);

		// subscribe to montage completed and interrupted events
		if (MontageLength > 0.0f)
		{
			// set the end delegate for the montage
			AnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);
		}
	}
}

void ACombatEnemy::DoAIChargedAttack()
{
	// ignore if we're already playing an attack animation
	if (bIsAttacking)
	{
		return;
	}

	// raise the attacking flag
	bIsAttacking = true;

	// choose how many loops are we going to charge for
	TargetChargeLoops = FMath::RandRange(MinChargeLoops, MaxChargeLoops);

	// reset the charge loop counter
	CurrentChargeLoop = 0;

	// play the attack montage
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		const float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);

		// subscribe to montage completed and interrupted events
		if (MontageLength > 0.0f)
		{
			// set the end delegate for the montage
			AnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);
		}
	}
}

void ACombatEnemy::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	// reset the attacking flag
	bIsAttacking = false;

	// call the attack completed delegate so the StateTree can continue execution
	OnAttackCompleted.ExecuteIfBound();
}

void ACombatEnemy::DoAttackTrace(FName DamageSourceBone)
{
	// sweep for objects in front of the character to be hit by the attack
	TArray<FHitResult> OutHits;

	// start at the provided socket location, sweep forward
	const FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);
	const FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);

	// enemies only affect Pawn collision objects; they don't knock back boxes
	FCollisionObjectQueryParams ObjectParams;
	ObjectParams.AddObjectTypesToQuery(ECC_Pawn);

	// use a sphere shape for the sweep
	FCollisionShape CollisionShape;
	CollisionShape.SetSphere(MeleeTraceRadius);

	// ignore self
	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(this);

	if (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))
	{
		// iterate over each object hit
		for (const FHitResult& CurrentHit : OutHits)
		{
			/** does the actor have the player tag? */
			if (CurrentHit.GetActor()->ActorHasTag(FName("Player")))
			{
				// check if the actor is damageable
				ICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());

				if (Damageable)
				{
					// knock upwards and away from the impact normal
					const FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);

					// pass the damage event to the actor
					Damageable->ApplyDamage(MeleeDamage, this, CurrentHit.ImpactPoint, Impulse);

				}
			}
		}
	}
}

void ACombatEnemy::CheckCombo()
{
	// increase the combo counter
	++CurrentComboAttack;

	// do we still have attacks to play in this string?
	if (CurrentComboAttack < TargetComboCount)
	{
		// jump to the next attack section
		if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
		{
			AnimInstance->Montage_JumpToSection(ComboSectionNames[CurrentComboAttack], ComboAttackMontage);
		}
	}
}

void ACombatEnemy::CheckChargedAttack()
{
	// increase the charge loop counter
	++CurrentChargeLoop;

	// jump to either the loop or attack section of the montage depending on whether we hit the loop target
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		AnimInstance->Montage_JumpToSection(CurrentChargeLoop >= TargetChargeLoops ? ChargeAttackSection : ChargeLoopSection, ChargedAttackMontage);
	}
}

void ACombatEnemy::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)
{
	
	// pass the damage event to the actor
	FDamageEvent DamageEvent;
	const float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);

	// only process knockback and effects if we received nonzero damage
	if (ActualDamage > 0.0f)
	{
		// apply the knockback impulse
		GetCharacterMovement()->AddImpulse(DamageImpulse, true);

		// is the character ragdolling?
		if (GetMesh()->IsSimulatingPhysics())
		{
			// apply an impulse to the ragdoll
			GetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);
		}

		// stop the attack montages to interrupt the attack
		if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
		{
			AnimInstance->Montage_Stop(0.1f, ComboAttackMontage);
			AnimInstance->Montage_Stop(0.1f, ChargedAttackMontage);
		}

		// pass control to BP to play effects, etc.
		ReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());
	}
}

void ACombatEnemy::HandleDeath()
{
	// hide the life bar
	LifeBar->SetHiddenInGame(true);

	// disable the collision capsule to avoid being hit again while dead
	GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);

	// disable character movement
	GetCharacterMovement()->DisableMovement();

	// enable full ragdoll physics
	GetMesh()->SetSimulatePhysics(true);

	// call the died delegate to notify any subscribers
	OnEnemyDied.Broadcast();

	// set up the death timer
	GetWorld()->GetTimerManager().SetTimer(DeathTimer, this, &ACombatEnemy::RemoveFromLevel, DeathRemovalTime);
}

void ACombatEnemy::ApplyHealing(float Healing, AActor* Healer)
{
	// stub
}

void ACombatEnemy::RemoveFromLevel()
{
	// destroy this actor
	Destroy();
}

float ACombatEnemy::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)
{
	// only process damage if the character is still alive
	if (CurrentHP <= 0.0f)
	{
		return 0.0f;
	}

	// reduce the current HP
	CurrentHP -= Damage;

	// have we run out of HP?
	if (CurrentHP <= 0.0f)
	{
		// die
		HandleDeath();
	}
	else
	{
		// update the life bar
		LifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);

		// enable partial ragdoll physics, but keep the pelvis vertical
		GetMesh()->SetPhysicsBlendWeight(0.5f);
		GetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);
	}

	// return the received damage amount
	return Damage;
}

void ACombatEnemy::Landed(const FHitResult& Hit)
{
	Super::Landed(Hit);

	// is the character still alive?
	if (CurrentHP >= 0.0f)
	{
		// disable ragdoll physics
		GetMesh()->SetPhysicsBlendWeight(0.0f);
	}

	// call the landed Delegate for StateTree
	OnEnemyLanded.ExecuteIfBound();
}

void ACombatEnemy::BeginPlay()
{
	// reset HP to maximum
	CurrentHP = MaxHP;

	// we top the HP before BeginPlay so StateTree picks it up at the right value
	Super::BeginPlay();

	// get the life bar widget from the widget comp
	LifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());
	check(LifeBarWidget);

	// fill the life bar
	LifeBarWidget->SetLifePercentage(1.0f);
}

void ACombatEnemy::EndPlay(EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the death timer
	GetWorld()->GetTimerManager().ClearTimer(DeathTimer);
}

================
File: ActionPractice\Variant_Combat\AI\CombatEnemy.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "CombatAttacker.h"
#include "CombatDamageable.h"
#include "Animation/AnimMontage.h"
#include "Engine/TimerHandle.h"
#include "CombatEnemy.generated.h"

class UWidgetComponent;
class UCombatLifeBar;
class UAnimMontage;

/** Completed attack animation delegate for StateTree */
DECLARE_DELEGATE(FOnEnemyAttackCompleted);

/** Landed delegate for StateTree */
DECLARE_DELEGATE(FOnEnemyLanded);

/** Enemy died delegate */
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEnemyDied);

/**
 *  An AI-controlled character with combat capabilities.
 *  Its bundled AI Controller runs logic through StateTree
 */
UCLASS(abstract)
class ACombatEnemy : public ACharacter, public ICombatAttacker, public ICombatDamageable
{
	GENERATED_BODY()

	/** Life bar widget component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = UI, meta = (AllowPrivateAccess = "true"))
	UWidgetComponent* LifeBar;

public:
	
	/** Constructor */
	ACombatEnemy();

protected:

	/** Max amount of HP the character will have on respawn */
	UPROPERTY(EditAnywhere, Category="Damage")
	float MaxHP = 3.0f;

public:

	/** Current amount of HP the character has */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Damage", meta = (ClampMin = 0, ClampMax = 100))
	float CurrentHP = 0.0f;

protected:

	/** Name of the pelvis bone, for damage ragdoll physics */
	UPROPERTY(EditAnywhere, Category="Damage")
	FName PelvisBoneName;

	/** Pointer to the life bar widget */
	UPROPERTY(EditAnywhere, Category="Damage")
	UCombatLifeBar* LifeBarWidget;

	/** If true, the character is currently playing an attack animation */
	bool bIsAttacking = false;

	/** Distance ahead of the character that melee attack sphere collision traces will extend */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Trace", meta = (ClampMin = 0, ClampMax = 500, Units = "cm"))
	float MeleeTraceDistance = 75.0f;

	/** Radius of the sphere trace for melee attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Trace", meta = (ClampMin = 0, ClampMax = 500, Units = "cm"))
	float MeleeTraceRadius = 50.0f;

	/** Amount of damage a melee attack will deal */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 100))
	float MeleeDamage = 1.0f;

	/** Amount of knockback impulse a melee attack will apply */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm/s"))
	float MeleeKnockbackImpulse = 150.0f;

	/** Amount of upwards impulse a melee attack will apply */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Damage", meta = (ClampMin = 0, ClampMax = 1000, Units = "cm/s"))
	float MeleeLaunchImpulse = 350.0f;

	/** AnimMontage that will play for combo attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Combo")
	UAnimMontage* ComboAttackMontage;

	/** Names of the AnimMontage sections that correspond to each stage of the combo attack */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Combo")
	TArray<FName> ComboSectionNames;

	/** Target number of attacks in the combo attack string we're playing */
	int32 TargetComboCount = 0;

	/** Index of the current stage of the melee attack combo */
	int32 CurrentComboAttack = 0;

	/** AnimMontage that will play for charged attacks */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	UAnimMontage* ChargedAttackMontage;

	/** Name of the AnimMontage section that corresponds to the charge loop */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	FName ChargeLoopSection;

	/** Name of the AnimMontage section that corresponds to the attack */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged")
	FName ChargeAttackSection;

	/** Minimum number of charge animation loops that will be played by the AI */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged", meta = (ClampMin = 1, ClampMax = 20))
	int32 MinChargeLoops = 2;

	/** Maximum number of charge animation loops that will be played by the AI */
	UPROPERTY(EditAnywhere, Category="Melee Attack|Charged", meta = (ClampMin = 1, ClampMax = 20))
	int32 MaxChargeLoops = 5;

	/** Target number of charge animation loops to play in this charged attack */
	int32 TargetChargeLoops = 0;

	/** Number of charge animation loop currently playing */
	int32 CurrentChargeLoop = 0;

	/** Time to wait before removing this character from the level after it dies */
	UPROPERTY(EditAnywhere, Category="Death")
	float DeathRemovalTime = 5.0f;

	/** Enemy death timer */
	FTimerHandle DeathTimer;

	/** Attack montage ended delegate */
	FOnMontageEnded OnAttackMontageEnded;

public:
	/** Attack completed internal delegate to notify StateTree tasks */
	FOnEnemyAttackCompleted OnAttackCompleted;

	/** Landed internal delegate to notify StateTree tasks. We use this instead of the built-in Landed delegate so we can bind to a Lambda in StateTree tasks */
	FOnEnemyLanded OnEnemyLanded;

	/** Enemy died delegate. Allows external subscribers to respond to enemy death */
	UPROPERTY(BlueprintAssignable, Category="Events")
	FOnEnemyDied OnEnemyDied;

public:

	/** Performs an AI-initiated combo attack. Number of hits will be decided by this character */
	void DoAIComboAttack();

	/** Performs an AI-initiated charged attack. Charge time will be decided by this character */
	void DoAIChargedAttack();

	/** Called from a delegate when the attack montage ends */
	void AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted);

public:

	// ~begin ICombatAttacker interface

	/** Performs an attack's collision check */
	virtual void DoAttackTrace(FName DamageSourceBone) override;

	/** Performs a combo attack's check to continue the string */
	UFUNCTION(BlueprintCallable, Category="Attacker")
	virtual void CheckCombo() override;

	/** Performs a charged attack's check to loop the charge animation */
	UFUNCTION(BlueprintCallable, Category="Attacker")
	virtual void CheckChargedAttack() override;

	// ~end ICombatAttacker interface

	// ~begin ICombatDamageable interface

	/** Handles damage and knockback events */
	virtual void ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse) override;

	/** Handles death events */
	virtual void HandleDeath() override;

	/** Handles healing events */
	virtual void ApplyHealing(float Healing, AActor* Healer) override;

	// ~end ICombatDamageable interface

protected:

	/** Removes this character from the level after it dies */
	void RemoveFromLevel();

public:

	/** Overrides the default TakeDamage functionality */
	virtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) override;

	/** Overrides landing to reset damage ragdoll physics */
	virtual void Landed(const FHitResult& Hit) override;

protected:

	/** Blueprint handler to play damage received effects */
	UFUNCTION(BlueprintImplementableEvent, Category="Combat")
	void ReceivedDamage(float Damage, const FVector& ImpactPoint, const FVector& DamageDirection);

protected:

	/** Gameplay initialization */
	virtual void BeginPlay() override;

	/** EndPlay cleanup */
	virtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;
};

================
File: ActionPractice\Variant_Combat\AI\CombatEnemySpawner.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatEnemySpawner.h"
#include "Components/SceneComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/ArrowComponent.h"
#include "TimerManager.h"
#include "CombatEnemy.h"

ACombatEnemySpawner::ACombatEnemySpawner()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the root
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));

	// create the reference spawn capsule
	SpawnCapsule = CreateDefaultSubobject<UCapsuleComponent>(TEXT("Spawn Capsule"));
	SpawnCapsule->SetupAttachment(RootComponent);

	SpawnCapsule->SetRelativeLocation(FVector(0.0f, 0.0f, 90.0f));
	SpawnCapsule->SetCapsuleSize(35.0f, 90.0f);
	SpawnCapsule->SetCollisionProfileName(FName("NoCollision"));

	SpawnDirection = CreateDefaultSubobject<UArrowComponent>(TEXT("Spawn Direction"));
	SpawnDirection->SetupAttachment(RootComponent);
}

void ACombatEnemySpawner::BeginPlay()
{
	Super::BeginPlay();
	
	// should we spawn an enemy right away?
	if (bShouldSpawnEnemiesImmediately)
	{
		// schedule the first enemy spawn
		GetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, InitialSpawnDelay);
	}

}

void ACombatEnemySpawner::EndPlay(EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the spawn timer
	GetWorld()->GetTimerManager().ClearTimer(SpawnTimer);
}

void ACombatEnemySpawner::SpawnEnemy()
{
	// ensure the enemy class is valid
	if (IsValid(EnemyClass))
	{
		// spawn the enemy at the reference capsule's transform
		FActorSpawnParameters SpawnParams;
		SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

		ACombatEnemy* SpawnedEnemy = GetWorld()->SpawnActor<ACombatEnemy>(EnemyClass, SpawnCapsule->GetComponentTransform(), SpawnParams);

		// was the enemy successfully created?
		if (SpawnedEnemy)
		{
			// subscribe to the death delegate
			SpawnedEnemy->OnEnemyDied.AddDynamic(this, &ACombatEnemySpawner::OnEnemyDied);
		}
	}
}

void ACombatEnemySpawner::OnEnemyDied()
{
	// decrease the spawn counter
	--SpawnCount;

	// is this the last enemy we should spawn?
	if (SpawnCount <= 0)
	{
		// schedule the activation on depleted message
		GetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnerDepleted, ActivationDelay);
		return;
	}

	// schedule the next enemy spawn
	GetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, RespawnDelay);
}

void ACombatEnemySpawner::SpawnerDepleted()
{
	// process the actors to activate list
	for (AActor* CurrentActor : ActorsToActivateWhenDepleted)
	{
		// check if the actor is activatable
		if (ICombatActivatable* CombatActivatable = Cast<ICombatActivatable>(CurrentActor))
		{
			// activate the actor
			CombatActivatable->ActivateInteraction(this);
		}
	}
}

void ACombatEnemySpawner::ToggleInteraction(AActor* ActivationInstigator)
{
	// stub
}

void ACombatEnemySpawner::ActivateInteraction(AActor* ActivationInstigator)
{
	// ensure we're only activated once, and only if we've deferred enemy spawning
	if (bHasBeenActivated || bShouldSpawnEnemiesImmediately)
	{
		return;
	}

	// raise the activation flag
	bHasBeenActivated = true;

	// spawn the first enemy
	SpawnEnemy();
}

void ACombatEnemySpawner::DeactivateInteraction(AActor* ActivationInstigator)
{
	// stub
}

================
File: ActionPractice\Variant_Combat\AI\CombatEnemySpawner.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CombatActivatable.h"
#include "CombatEnemySpawner.generated.h"

class UCapsuleComponent;
class UArrowComponent;
class ACombatEnemy;

/**
 *  A basic Actor in charge of spawning Enemy Characters and monitoring their deaths.
 *  Enemies will be spawned one by one, and the spawner will wait until the enemy dies before spawning a new one.
 *  The spawner can be remotely activated through the ICombatActivatable interface
 *  When the last spawned enemy dies, the spawner can also activate other ICombatActivatables
 */
UCLASS(abstract)
class ACombatEnemySpawner : public AActor, public ICombatActivatable
{
	GENERATED_BODY()
	
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Components, meta = (AllowPrivateAccess = "true"))
	UCapsuleComponent* SpawnCapsule;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Components, meta = (AllowPrivateAccess = "true"))
	UArrowComponent* SpawnDirection;

protected:

	/** Type of enemy to spawn */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy Spawner")
	TSubclassOf<ACombatEnemy> EnemyClass;

	/** If true, the first enemy will be spawned as soon as the game starts */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy Spawner")
	bool bShouldSpawnEnemiesImmediately = true;

	/** Time to wait before spawning the first enemy on game start */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy Spawner", meta = (ClampMin = 0, ClampMax = 10))
	float InitialSpawnDelay = 5.0f;

	/** Number of enemies to spawn */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy Spawner", meta = (ClampMin = 0, ClampMax = 100))
	int32 SpawnCount = 1;

	/** Time to wait before spawning the next enemy after the current one dies */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy Spawner", meta = (ClampMin = 0, ClampMax = 10))
	float RespawnDelay = 5.0f;

	/** Time to wait after this spawner is depleted before activating the actor list */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Activation", meta = (ClampMin = 0, ClampMax = 10))
	float ActivationDelay = 1.0f;

	/** List of actors to activate after the last enemy dies */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Activation")
	TArray<AActor*> ActorsToActivateWhenDepleted;

	/** Flag to ensure this is only activated once */
	bool bHasBeenActivated = false;

	/** Timer to spawn enemies after a delay */
	FTimerHandle SpawnTimer;

public:	
	
	/** Constructor */
	ACombatEnemySpawner();

public:

	/** Initialization */
	virtual void BeginPlay() override;

	/** Cleanup */
	virtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;

protected:

	/** Spawn an enemy and subscribe to its death event */
	void SpawnEnemy();

	/** Called when the spawned enemy has died */
	UFUNCTION()
	void OnEnemyDied();

	/** Called after the last spawned enemy has died */
	void SpawnerDepleted();

public:

	// ~begin ICombatActivatable interface

	/** Toggles the Spawner */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void ToggleInteraction(AActor* ActivationInstigator) override;

	/** Activates the Spawner */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void ActivateInteraction(AActor* ActivationInstigator) override;

	/** Deactivates the Spawner */
	UFUNCTION(BlueprintCallable, Category="Activatable")
	virtual void DeactivateInteraction(AActor* ActivationInstigator) override;

	// ~end IActivatable interface
};

================
File: ActionPractice\Variant_Combat\AI\CombatStateTreeUtility.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "CombatStateTreeUtility.h"
#include "StateTreeExecutionContext.h"
#include "StateTreeExecutionTypes.h"
#include "GameFramework/Character.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "AIController.h"
#include "CombatEnemy.h"
#include "Kismet/GameplayStatics.h"
#include "StateTreeAsyncExecutionContext.h"

bool FStateTreeCharacterGroundedCondition::TestCondition(FStateTreeExecutionContext& Context) const
{
	const FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

	// is the character currently grounded?
	bool bCondition = InstanceData.Character->GetMovementComponent()->IsMovingOnGround();

	return InstanceData.bMustBeOnAir ? !bCondition : bCondition;
}

#if WITH_EDITOR
FText FStateTreeCharacterGroundedCondition::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Is Character Grounded</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeComboAttackTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// bind to the on attack completed delegate
		InstanceData.Character->OnAttackCompleted.BindLambda(
			[WeakContext = Context.MakeWeakExecutionContext()]()
			{
				WeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);
			}
		);


		// tell the character to do a combo attack
		InstanceData.Character->DoAIComboAttack();
	}

	return EStateTreeRunStatus::Running;
}

void FStateTreeComboAttackTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// unbind the on attack completed delegate
		InstanceData.Character->OnAttackCompleted.Unbind();
	}
}

#if WITH_EDITOR
FText FStateTreeComboAttackTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Do Combo Attack</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeChargedAttackTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// bind to the on attack completed delegate
		InstanceData.Character->OnAttackCompleted.BindLambda(
			[WeakContext = Context.MakeWeakExecutionContext()]()
			{
				WeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);
			}
		);

		// tell the character to do a combo attack
		InstanceData.Character->DoAIChargedAttack();
	}

	return EStateTreeRunStatus::Running;
}

void FStateTreeChargedAttackTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// unbind the on attack completed delegate
		InstanceData.Character->OnAttackCompleted.Unbind();
	}
}

#if WITH_EDITOR
FText FStateTreeChargedAttackTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Do Charged Attack</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeWaitForLandingTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// bind to the on enemy landed delegate
		InstanceData.Character->OnEnemyLanded.BindLambda(
			[WeakContext = Context.MakeWeakExecutionContext()]()
			{
				WeakContext.FinishTask(EStateTreeFinishTaskType::Succeeded);
			}
		);
	}

	return EStateTreeRunStatus::Running;
}

void FStateTreeWaitForLandingTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// bind the on enemy landed delegate
		InstanceData.Character->OnEnemyLanded.Unbind();
	}
}

#if WITH_EDITOR
FText FStateTreeWaitForLandingTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Wait for Landing</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeFaceActorTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// set the AI Controller's focus
		InstanceData.Controller->SetFocus(InstanceData.ActorToFaceTowards);
	}

	return EStateTreeRunStatus::Running;
}

void FStateTreeFaceActorTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned to another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// clear the AI Controller's focus
		InstanceData.Controller->ClearFocus(EAIFocusPriority::Gameplay);
	}
}

#if WITH_EDITOR
FText FStateTreeFaceActorTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Face Towards Actor</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeFaceLocationTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// set the AI Controller's focus
		InstanceData.Controller->SetFocalPoint(InstanceData.FaceLocation);
	}

	return EStateTreeRunStatus::Running;
}

void FStateTreeFaceLocationTask::ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned to another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// clear the AI Controller's focus
		InstanceData.Controller->ClearFocus(EAIFocusPriority::Gameplay);
	}
}

#if WITH_EDITOR
FText FStateTreeFaceLocationTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Face Towards Location</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeSetCharacterSpeedTask::EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const
{
	// have we transitioned from another state?
	if (Transition.ChangeType == EStateTreeStateChangeType::Changed)
	{
		// get the instance data
		FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

		// set the character's max ground speed
		InstanceData.Character->GetCharacterMovement()->MaxWalkSpeed = InstanceData.Speed;
	}

	return EStateTreeRunStatus::Running;
}

#if WITH_EDITOR
FText FStateTreeSetCharacterSpeedTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Set Character Speed</b>");
}
#endif // WITH_EDITOR

////////////////////////////////////////////////////////////////////

EStateTreeRunStatus FStateTreeGetPlayerInfoTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	// get the instance data
	FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

	// get the character possessed by the first local player
	InstanceData.TargetPlayerCharacter = Cast<ACharacter>(UGameplayStatics::GetPlayerPawn(InstanceData.Character, 0));

	// do we have a valid target?
	if (InstanceData.TargetPlayerCharacter)
	{
		// update the last known location
		InstanceData.TargetPlayerLocation = InstanceData.TargetPlayerCharacter->GetActorLocation();
	}

	// update the distance
	InstanceData.DistanceToTarget = FVector::Distance(InstanceData.TargetPlayerLocation, InstanceData.Character->GetActorLocation());

	return EStateTreeRunStatus::Running;
}

#if WITH_EDITOR
FText FStateTreeGetPlayerInfoTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Get Player Info</b>");
}
#endif // WITH_EDITOR

================
File: ActionPractice\Variant_Combat\AI\CombatStateTreeUtility.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "StateTreeTaskBase.h"
#include "StateTreeConditionBase.h"

#include "CombatStateTreeUtility.generated.h"

class ACharacter;
class AAIController;
class ACombatEnemy;

/**
 *  Instance data struct for the FStateTreeCharacterGroundedCondition condition
 */
USTRUCT()
struct FStateTreeCharacterGroundedConditionInstanceData
{
	GENERATED_BODY()
	
	/** Character to check grounded status on */
	UPROPERTY(EditAnywhere, Category = "Context")
	ACharacter* Character;

	/** If true, the condition passes if the character is not grounded instead */
	UPROPERTY(EditAnywhere, Category = "Condition")
	bool bMustBeOnAir = false;
};
STATETREE_POD_INSTANCEDATA(FStateTreeCharacterGroundedConditionInstanceData);

/**
 *  StateTree condition to check if the character is grounded
 */
USTRUCT(DisplayName = "Character is Grounded")
struct FStateTreeCharacterGroundedCondition : public FStateTreeConditionCommonBase
{
	GENERATED_BODY()

	/** Set the instance data type */
	using FInstanceDataType = FStateTreeCharacterGroundedConditionInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Default constructor */
	FStateTreeCharacterGroundedCondition() = default;
	
	/** Tests the StateTree condition */
	virtual bool TestCondition(FStateTreeExecutionContext& Context) const override;

#if WITH_EDITOR

	/** Provides the description string */
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif

};

////////////////////////////////////////////////////////////////////

/**
 *  Instance data struct for the Combat StateTree tasks
 */
USTRUCT()
struct FStateTreeAttackInstanceData
{
	GENERATED_BODY()

	/** Character that will perform the attack */
	UPROPERTY(EditAnywhere, Category = Context)
	TObjectPtr<ACombatEnemy> Character;
};

/**
 *  StateTree task to perform a combo attack
 */
USTRUCT(meta=(DisplayName="Combo Attack", Category="Combat"))
struct FStateTreeComboAttackTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeAttackInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	/** Runs when the owning state is ended */
	virtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

/**
 *  StateTree task to perform a charged attack
 */
USTRUCT(meta=(DisplayName="Charged Attack", Category="Combat"))
struct FStateTreeChargedAttackTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeAttackInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	/** Runs when the owning state is ended */
	virtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

/**
 *  StateTree task to wait for the character to land
 */
USTRUCT(meta=(DisplayName="Wait for Landing", Category="Combat"))
struct FStateTreeWaitForLandingTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeAttackInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	/** Runs when the owning state is ended */
	virtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

////////////////////////////////////////////////////////////////////

/**
 *  Instance data struct for the Face Towards Actor StateTree task
 */
USTRUCT()
struct FStateTreeFaceActorInstanceData
{
	GENERATED_BODY()

	/** AI Controller that will determine the focused actor */
	UPROPERTY(EditAnywhere, Category = Context)
	TObjectPtr<AAIController> Controller;

	/** Actor that will be faced towards */
	UPROPERTY(EditAnywhere, Category = Input)
	TObjectPtr<AActor> ActorToFaceTowards;
};

/**
 *  StateTree task to face an AI-Controlled Pawn towards an Actor
 */
USTRUCT(meta=(DisplayName="Face Towards Actor", Category="Combat"))
struct FStateTreeFaceActorTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeFaceActorInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	/** Runs when the owning state is ended */
	virtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

////////////////////////////////////////////////////////////////////

/**
 *  Instance data struct for the Face Towards Location StateTree task
 */
USTRUCT()
struct FStateTreeFaceLocationInstanceData
{
	GENERATED_BODY()

	/** AI Controller that will determine the focused location */
	UPROPERTY(EditAnywhere, Category = Context)
	TObjectPtr<AAIController> Controller;

	/** Location that will be faced towards */
	UPROPERTY(EditAnywhere, Category = Parameter)
	FVector FaceLocation;
};

/**
 *  StateTree task to face an AI-Controlled Pawn towards a world location
 */
USTRUCT(meta=(DisplayName="Face Towards Location", Category="Combat"))
struct FStateTreeFaceLocationTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeFaceLocationInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	/** Runs when the owning state is ended */
	virtual void ExitState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

////////////////////////////////////////////////////////////////////

/**
 *  Instance data struct for the Set Character Speed StateTree task
 */
USTRUCT()
struct FStateTreeSetCharacterSpeedInstanceData
{
	GENERATED_BODY()

	/** Character that will be affected */
	UPROPERTY(EditAnywhere, Category = Context)
	TObjectPtr<ACharacter> Character;

	/** Max ground speed to set for the character */
	UPROPERTY(EditAnywhere, Category = Parameter)
	float Speed = 600.0f;
};

/**
 *  StateTree task to change a Character's ground speed
 */
USTRUCT(meta=(DisplayName="Set Character Speed", Category="Combat"))
struct FStateTreeSetCharacterSpeedTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeSetCharacterSpeedInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs when the owning state is entered */
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

////////////////////////////////////////////////////////////////////

/**
 *  Instance data struct for the Get Player Info task
 */
USTRUCT()
struct FStateTreeGetPlayerInfoInstanceData
{
	GENERATED_BODY()

	/** Character that owns this task */
	UPROPERTY(EditAnywhere, Category = Context)
	TObjectPtr<ACharacter> Character;

	/** Character that owns this task */
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<ACharacter> TargetPlayerCharacter;

	/** Last known location for the target */
	UPROPERTY(VisibleAnywhere)
	FVector TargetPlayerLocation;

	/** Distance to the target */
	UPROPERTY(VisibleAnywhere)
	float DistanceToTarget;
};

/**
 *  StateTree task to get information about the player character
 */
USTRUCT(meta=(DisplayName="GetPlayerInfo", Category="Combat"))
struct FStateTreeGetPlayerInfoTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeGetPlayerInfoInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs while the owning state is active */
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

================
File: ActionPractice\Variant_Combat\AI\EnvQueryContext_Player.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "EnvQueryContext_Player.h"
#include "Kismet/GameplayStatics.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "EnvironmentQuery/Items/EnvQueryItemType_Actor.h"
#include "GameFramework/Pawn.h"

void UEnvQueryContext_Player::ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const
{
	// get the player pawn for the first local player
	AActor* PlayerPawn = UGameplayStatics::GetPlayerPawn(QueryInstance.Owner.Get(), 0);
	check(PlayerPawn);

	// add the actor data to the context
	UEnvQueryItemType_Actor::SetContextHelper(ContextData, PlayerPawn);
}

================
File: ActionPractice\Variant_Combat\AI\EnvQueryContext_Player.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "EnvironmentQuery/EnvQueryContext.h"
#include "EnvQueryContext_Player.generated.h"

/**
 *  UEnvQueryContext_Player
 *  Basic EnvQuery Context that returns the first local player
 */
UCLASS()
class UEnvQueryContext_Player : public UEnvQueryContext
{
	GENERATED_BODY()
	
public:

	/** Provides the context locations or actors for this EnvQuery */
	virtual void ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const override;
};

================
File: ActionPractice\Variant_Platforming\AnimNotify_EndDash.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "AnimNotify_EndDash.h"
#include "PlatformingCharacter.h"
#include "Components/SkeletalMeshComponent.h"

void UAnimNotify_EndDash::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	// cast the owner to the attacker interface
	if (APlatformingCharacter* PlatformingCharacter = Cast<APlatformingCharacter>(MeshComp->GetOwner()))
	{
		// tell the actor to end the dash
		PlatformingCharacter->EndDash();
	}
}

FString UAnimNotify_EndDash::GetNotifyName_Implementation() const
{
	return FString("End Dash");
}

================
File: ActionPractice\Variant_Platforming\AnimNotify_EndDash.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotify.h"
#include "AnimNotify_EndDash.generated.h"

/**
 *  AnimNotify to finish the dash animation and restore player control
 */
UCLASS()
class UAnimNotify_EndDash : public UAnimNotify
{
	GENERATED_BODY()
	
public:

	/** Perform the Anim Notify */
	virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;

	/** Get the notify name */
	virtual FString GetNotifyName_Implementation() const override;
};

================
File: ActionPractice\Variant_Platforming\PlatformingCharacter.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "PlatformingCharacter.h"

#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "Camera/CameraComponent.h"
#include "EnhancedInputSubsystems.h"
#include "EnhancedInputComponent.h"
#include "TimerManager.h"
#include "Engine/LocalPlayer.h"

APlatformingCharacter::APlatformingCharacter()
{
 	PrimaryActorTick.bCanEverTick = true;

	// initialize the flags
	bHasWallJumped = false;
	bHasDoubleJumped = false;
	bHasDashed = false;
	bIsDashing = false;

	// bind the attack montage ended delegate
	OnDashMontageEnded.BindUObject(this, &APlatformingCharacter::DashMontageEnded);

	// enable press and hold jump
	JumpMaxHoldTime = 0.4f;

	// set the jump max count to 2 so we can double jump
	JumpMaxCount = 2;

	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);

	// don't rotate the mesh when the controller rotates
	bUseControllerRotationYaw = false;
	
	// Configure character movement
	GetCharacterMovement()->GravityScale = 2.5f;
	GetCharacterMovement()->MaxAcceleration = 1500.0f;
	GetCharacterMovement()->BrakingFrictionFactor = 1.0f;
	GetCharacterMovement()->bUseSeparateBrakingFriction = true;

	GetCharacterMovement()->GroundFriction = 4.0f;
	GetCharacterMovement()->MaxWalkSpeed = 750.0f;
	GetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2500.0f;
	GetCharacterMovement()->PerchRadiusThreshold = 15.0f;

	GetCharacterMovement()->JumpZVelocity = 350.0f;
	GetCharacterMovement()->BrakingDecelerationFalling = 750.0f;
	GetCharacterMovement()->AirControl = 1.0f;

	GetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);
	GetCharacterMovement()->bOrientRotationToMovement = true;

	GetCharacterMovement()->NavAgentProps.AgentRadius = 42.0;
	GetCharacterMovement()->NavAgentProps.AgentHeight = 192.0;

	// create the camera boom
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);

	CameraBoom->TargetArmLength = 400.0f;
	CameraBoom->bUsePawnControlRotation = true;
	CameraBoom->bEnableCameraLag = true;
	CameraBoom->CameraLagSpeed = 8.0f;
	CameraBoom->bEnableCameraRotationLag = true;	
	CameraBoom->CameraRotationLagSpeed = 8.0f;

	// create the orbiting camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
	FollowCamera->bUsePawnControlRotation = false;
}

void APlatformingCharacter::Move(const FInputActionValue& Value)
{
	FVector2D MovementVector = Value.Get<FVector2D>();

	// route the input
	DoMove(MovementVector.X, MovementVector.Y);
}

void APlatformingCharacter::Look(const FInputActionValue& Value)
{
	FVector2D LookAxisVector = Value.Get<FVector2D>();

	// route the input
	DoLook(LookAxisVector.X, LookAxisVector.Y);
}


void APlatformingCharacter::Dash()
{
	// route the input
	DoDash();
}

void APlatformingCharacter::MultiJump()
{
	// ignore jumps while dashing
	if(bIsDashing)
		return;

	// are we already in the air?
	if (GetCharacterMovement()->IsFalling())
	{

		// have we already wall jumped?
		if (!bHasWallJumped)
		{
			// run a sphere sweep to check if we're in front of a wall
			FHitResult OutHit;

			const FVector TraceStart = GetActorLocation();
			const FVector TraceEnd = TraceStart + (GetActorForwardVector() * WallJumpTraceDistance);
			const FCollisionShape TraceShape = FCollisionShape::MakeSphere(WallJumpTraceRadius);

			FCollisionQueryParams QueryParams;
			QueryParams.AddIgnoredActor(this);

			if (GetWorld()->SweepSingleByChannel(OutHit, TraceStart, TraceEnd, FQuat(), ECollisionChannel::ECC_Visibility, TraceShape, QueryParams))
			{
				// rotate the character to face away from the wall, so we're correctly oriented for the next wall jump
				FRotator WallOrientation = OutHit.ImpactNormal.ToOrientationRotator();
				WallOrientation.Pitch = 0.0f;
				WallOrientation.Roll = 0.0f;

				SetActorRotation(WallOrientation);

				// apply a launch impulse to the character to perform the actual wall jump
				const FVector WallJumpImpulse = (OutHit.ImpactNormal * WallJumpBounceImpulse) + (FVector::UpVector * WallJumpVerticalImpulse);

				LaunchCharacter(WallJumpImpulse, true, true);

				// enable the jump trail
				SetJumpTrailState(true);

				// raise the wall jump flag to prevent an immediate second wall jump
				bHasWallJumped = true;

				GetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &APlatformingCharacter::ResetWallJump, DelayBetweenWallJumps, false);
			}
			// no wall jump, try a double jump next
			else
			{
				// only double jump once while we're in the air
				if (!bHasDoubleJumped)
				{
					bHasDoubleJumped = true;

					// use the built-in CMC functionality to do the double jump
					Jump();

					// enable the jump trail
					SetJumpTrailState(true);
				}
			}
		}

	}
	else
	{
		// we're grounded so just do a regular jump
		Jump();

		// activate the jump trail
		SetJumpTrailState(true);
	}
}

void APlatformingCharacter::ResetWallJump()
{
	// reset the wall jump input lock
	bHasWallJumped = false;
}

void APlatformingCharacter::DoMove(float Right, float Forward)
{
	if (GetController() != nullptr)
	{
		// momentarily disable movement inputs if we've just wall jumped
		if (!bHasWallJumped)
		{
			// find out which way is forward
			const FRotator Rotation = GetController()->GetControlRotation();
			const FRotator YawRotation(0, Rotation.Yaw, 0);

			// get forward vector
			const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);

			// get right vector 
			const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

			// add movement 
			AddMovementInput(ForwardDirection, Forward);
			AddMovementInput(RightDirection, Right);
		}
	}
}

void APlatformingCharacter::DoLook(float Yaw, float Pitch)
{
	if (GetController() != nullptr)
	{
		// add yaw and pitch input to controller
		AddControllerYawInput(Yaw);
		AddControllerPitchInput(Pitch);
	}
}

void APlatformingCharacter::DoDash()
{
	// ignore the input if we've already dashed and have yet to reset
	if (bHasDashed)
		return;

	// raise the dash flags
	bIsDashing = true;
	bHasDashed = true;

	// disable gravity while dashing
	GetCharacterMovement()->GravityScale = 0.0f;

	// reset the character velocity so we don't carry momentum into the dash
	GetCharacterMovement()->Velocity = FVector::ZeroVector;

	// enable the jump trails
	SetJumpTrailState(true);

	// play the dash montage
	if (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())
	{
		const float MontageLength = AnimInstance->Montage_Play(DashMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);

		// has the montage played successfully?
		if (MontageLength > 0.0f)
		{
			AnimInstance->Montage_SetEndDelegate(OnDashMontageEnded, DashMontage);
		}
	}
}

void APlatformingCharacter::DoJumpStart()
{
	// handle special jump cases
	MultiJump();
}

void APlatformingCharacter::DoJumpEnd()
{
	// stop jumping
	StopJumping();
}

void APlatformingCharacter::DashMontageEnded(UAnimMontage* Montage, bool bInterrupted)
{
	// if the montage was interrupted, end the dash
	if (bInterrupted)
	{
		EndDash();
	}
}

void APlatformingCharacter::EndDash()
{
	// restore gravity
	GetCharacterMovement()->GravityScale = 2.5f;

	// reset the dashing flag
	bIsDashing = false;

	// are we grounded after the dash?
	if (GetCharacterMovement()->IsMovingOnGround())
	{
		// reset the dash usage flag, since we won't receive a landed event
		bHasDashed = false;

		// deactivate the jump trails
		SetJumpTrailState(false);
	}
}

bool APlatformingCharacter::HasDoubleJumped() const
{
	return bHasDoubleJumped;
}

bool APlatformingCharacter::HasWallJumped() const
{
	return bHasWallJumped;
}

void APlatformingCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the wall jump reset timer
	GetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);
}

void APlatformingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	// Set up action bindings
	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
	{

		// Jumping
		EnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &APlatformingCharacter::DoJumpStart);
		EnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &APlatformingCharacter::DoJumpEnd);

		// Moving
		EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Move);
		EnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);

		// Looking
		EnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);

		// Dashing
		EnhancedInputComponent->BindAction(DashAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Dash);
	}
}

void APlatformingCharacter::Landed(const FHitResult& Hit)
{
	Super::Landed(Hit);

	// reset the double jump and dash flags
	bHasDoubleJumped = false;
	bHasDashed = false;

	// deactivate the jump trail
	SetJumpTrailState(false);
}

================
File: ActionPractice\Variant_Platforming\PlatformingCharacter.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Animation/AnimInstance.h"
#include "PlatformingCharacter.generated.h"


class USpringArmComponent;
class UCameraComponent;
class UInputAction;
struct FInputActionValue;
class UAnimMontage;

/**
 *  An enhanced Third Person Character with the following functionality:
 *  - Platforming game character movement physics
 *  - Press and Hold Jump
 *  - Double Jump
 *  - Wall Jump
 *  - Dash
 */
UCLASS(abstract)
class APlatformingCharacter : public ACharacter
{
	GENERATED_BODY()

	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	USpringArmComponent* CameraBoom;

	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	UCameraComponent* FollowCamera;
	
protected:

	/** Jump Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* JumpAction;

	/** Move Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* MoveAction;

	/** Look Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* LookAction;

	/** Mouse Look Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* MouseLookAction;

	/** Dash Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* DashAction;

public:

	/** Constructor */
	APlatformingCharacter();

protected:

	/** Called for movement input */
	void Move(const FInputActionValue& Value);

	/** Called for looking input */
	void Look(const FInputActionValue& Value);

	/** Called for dash input */
	void Dash();

	/** Called for jump pressed to check for advanced multi-jump conditions */
	void MultiJump();

	/** Resets the wall jump input lock */
	void ResetWallJump();

public:

	/** Handles move inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoMove(float Right, float Forward);

	/** Handles look inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoLook(float Yaw, float Pitch);

	/** Handles dash inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoDash();

	/** Handles jump pressed inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoJumpStart();

	/** Handles jump pressed inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoJumpEnd();

protected:

	/** Called from a delegate when the dash montage ends */
	void DashMontageEnded(UAnimMontage* Montage, bool bInterrupted);

	/** Passes control to Blueprint to enable or disable jump trails */
	UFUNCTION(BlueprintImplementableEvent, Category="Platforming")
	void SetJumpTrailState(bool bEnabled);

public:

	/** Ends the dash state */
	void EndDash();

public:

	/** Returns true if the character has just double jumped */
	UFUNCTION(BlueprintPure, Category="Platforming")
	bool HasDoubleJumped() const;

	/** Returns true if the character has just wall jumped */
	UFUNCTION(BlueprintPure, Category="Platforming")
	bool HasWallJumped() const;

public:	
	
	/** EndPlay cleanup */
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	/** Sets up input action bindings */
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	/** Handle landings to reset dash and advanced jump state */
	virtual void Landed(const FHitResult& Hit) override;

protected:

	/** movement state flag bits, packed into a uint8 for memory efficiency */
	uint8 bHasWallJumped : 1;
	uint8 bHasDoubleJumped : 1;
	uint8 bHasDashed : 1;
	uint8 bIsDashing : 1;

	/** timer for wall jump input reset */
	FTimerHandle WallJumpTimer;

	/** Dash montage ended delegate */
	FOnMontageEnded OnDashMontageEnded;

	/** Distance to trace ahead of the character to look for walls to jump from */
	UPROPERTY(EditAnywhere, Category="Wall Jump")
	float WallJumpTraceDistance = 50.0f;

	/** Radius of the wall jump sphere trace check */
	UPROPERTY(EditAnywhere, Category="Wall Jump")
	float WallJumpTraceRadius = 25.0f;

	/** Impulse to apply away from the wall when wall jumping */
	UPROPERTY(EditAnywhere, Category="Wall Jump")
	float WallJumpBounceImpulse = 800.0f;

	/** Vertical impulse to apply when wall jumping */
	UPROPERTY(EditAnywhere, Category="Wall Jump")
	float WallJumpVerticalImpulse = 900.0f;

	/** Time to ignore jump inputs after a wall jump */
	UPROPERTY(EditAnywhere, Category="Wall Jump")
	float DelayBetweenWallJumps = 0.1f;

	/** AnimMontage to use for the Dash action */
	UPROPERTY(EditAnywhere, Category="Dash")
	UAnimMontage* DashMontage;

public:
	/** Returns CameraBoom subobject **/
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }

	/** Returns FollowCamera subobject **/
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }

};

================
File: ActionPractice\Variant_Platforming\PlatformingGameMode.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Variant_Platforming/PlatformingGameMode.h"

APlatformingGameMode::APlatformingGameMode()
{
	// stub
}

================
File: ActionPractice\Variant_Platforming\PlatformingGameMode.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "PlatformingGameMode.generated.h"

/**
 *  Simple GameMode for a third person platforming game
 */
UCLASS()
class APlatformingGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
public:

	/** Constructor */
	APlatformingGameMode();
};

================
File: ActionPractice\Variant_Platforming\PlatformingPlayerController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "Variant_Platforming/PlatformingPlayerController.h"
#include "EnhancedInputSubsystems.h"
#include "InputMappingContext.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/PlayerStart.h"
#include "PlatformingCharacter.h"
#include "Engine/LocalPlayer.h"
#include "Engine/World.h"

void APlatformingPlayerController::SetupInputComponent()
{
	// add the input mapping context
	if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))
	{
		for (UInputMappingContext* CurrentContext : DefaultMappingContexts)
		{
			Subsystem->AddMappingContext(CurrentContext, 0);
		}
	}
}

void APlatformingPlayerController::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);

	// subscribe to the pawn's OnDestroyed delegate
	InPawn->OnDestroyed.AddDynamic(this, &APlatformingPlayerController::OnPawnDestroyed);
}

void APlatformingPlayerController::OnPawnDestroyed(AActor* DestroyedActor)
{
	// find the player start
	TArray<AActor*> ActorList;
	UGameplayStatics::GetAllActorsOfClass(GetWorld(), APlayerStart::StaticClass(), ActorList);

	if (ActorList.Num() > 0)
	{
		// spawn a character at the player start
		const FTransform SpawnTransform = ActorList[0]->GetActorTransform();

		if (APlatformingCharacter* RespawnedCharacter = GetWorld()->SpawnActor<APlatformingCharacter>(CharacterClass, SpawnTransform))
		{
			// possess the character
			Possess(RespawnedCharacter);
		}
	}
}

================
File: ActionPractice\Variant_Platforming\PlatformingPlayerController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "PlatformingPlayerController.generated.h"

class UInputMappingContext;
class APlatformingCharacter;

/**
 *  Simple Player Controller for a third person platforming game
 *  Manages input mappings
 *  Respawns the player character at the Player Start when it's destroyed
 */
UCLASS(abstract)
class APlatformingPlayerController : public APlayerController
{
	GENERATED_BODY()
	
protected:

	/** Input mapping context for this player */
	UPROPERTY(EditAnywhere, Category="Input")
	TArray<UInputMappingContext*> DefaultMappingContexts;

	/** Character class to respawn when the possessed pawn is destroyed */
	UPROPERTY(EditAnywhere, Category="Respawn")
	TSubclassOf<APlatformingCharacter> CharacterClass;

protected:

	/** Initialize input bindings */
	virtual void SetupInputComponent() override;

	/** Pawn initialization */
	virtual void OnPossess(APawn* InPawn) override;

	/** Called if the possessed pawn is destroyed */
	UFUNCTION()
	void OnPawnDestroyed(AActor* DestroyedActor);
};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingCameraManager.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingCameraManager.h"
#include "GameFramework/Pawn.h"
#include "Engine/HitResult.h"
#include "CollisionQueryParams.h"
#include "Engine/World.h"

void ASideScrollingCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)
{
	// ensure the view target is a pawn
	APawn* TargetPawn = Cast<APawn>(OutVT.Target);

	// is our target valid?
	if (IsValid(TargetPawn))
	{
		// set the view target FOV and rotation
		OutVT.POV.Rotation = FRotator(0.0f, -90.0f, 0.0f);
		OutVT.POV.FOV = 65.0f;

		// cache the current location
		FVector CurrentActorLocation = OutVT.Target->GetActorLocation();

		// copy the current camera location
		FVector CurrentCameraLocation = GetCameraLocation();

		// calculate the "zoom distance" - in reality the distance we want to keep to the target
		float CurrentY = CurrentZoom + CurrentActorLocation.Y;

		// do first-time setup
		if (bSetup)
		{
			// lower the setup flag
			bSetup = false;

			// initialize the camera viewpoint and return
			OutVT.POV.Location.X = CurrentActorLocation.X;
			OutVT.POV.Location.Y = CurrentY;
			OutVT.POV.Location.Z = CurrentActorLocation.Z + CameraZOffset;

			// save the current camera height
			CurrentZ = OutVT.POV.Location.Z;

			// skip the rest of the calculations
			return;
		}

		// check if the camera needs to update its height
		bool bZUpdate = false;

		// is the character moving vertically?
		if (FMath::IsNearlyZero(TargetPawn->GetVelocity().Z))
		{
			// determine if we need to do a height update
			bZUpdate = FMath::IsNearlyEqual(CurrentZ, CurrentCameraLocation.Z, 25.0f);

		} else {

			// run a trace below the character to determine if we need to do a height update
			FHitResult OutHit;

			const FVector End = CurrentActorLocation + FVector(0.0f, 0.0f, -1000.0f);

			FCollisionQueryParams QueryParams;
			QueryParams.AddIgnoredActor(TargetPawn);

			// only update height if we're not about to hit ground
			bZUpdate = !GetWorld()->LineTraceSingleByChannel(OutHit, CurrentActorLocation, End, ECC_Visibility, QueryParams);

		}

		// do we need to do a height update?
		if (bZUpdate)
		{

			// set the height goal from the actor location
			CurrentZ = CurrentActorLocation.Z;

		} else {

			// are we close enough to the target height?
			if (FMath::IsNearlyEqual(CurrentZ, CurrentActorLocation.Z, 100.0f))
			{
				// set the height goal from the actor location
				CurrentZ = CurrentActorLocation.Z;

			} else {

				// blend the height towards the actor location
				CurrentZ = FMath::FInterpTo(CurrentZ, CurrentActorLocation.Z, DeltaTime, 2.0f);
				
			}

		}

		// clamp the X axis to the min and max camera bounds
		float CurrentX = FMath::Clamp(CurrentActorLocation.X, CameraXMinBounds, CameraXMaxBounds);

		// blend towards the new camera location and update the output
		FVector TargetCameraLocation(CurrentX, CurrentY, CurrentZ);

		OutVT.POV.Location = FMath::VInterpTo(CurrentCameraLocation, TargetCameraLocation, DeltaTime, 2.0f);
	}
}

================
File: ActionPractice\Variant_SideScrolling\SideScrollingCameraManager.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Camera/PlayerCameraManager.h"
#include "SideScrollingCameraManager.generated.h"

/**
 *  Simple side scrolling camera with smooth scrolling and horizontal bounds
 */
UCLASS()
class ASideScrollingCameraManager : public APlayerCameraManager
{
	GENERATED_BODY()
	
public:

	/** Overrides the default camera view target calculation */
	virtual void UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime) override;

public:

	/** How close we want to stay to the view target */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Side Scrolling Camera", meta=(ClampMin=0, ClampMax=10000, Units="cm"))
	float CurrentZoom = 1000.0f;

	/** How far above the target do we want the camera to focus */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Side Scrolling Camera", meta=(ClampMin=0, ClampMax=10000, Units="cm"))
	float CameraZOffset = 100.0f;

	/** Minimum camera scrolling bounds in world space */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Side Scrolling Camera", meta=(ClampMin=0, ClampMax=10000, Units="cm"))
	float CameraXMinBounds = -400.0f;

	/** Maximum camera scrolling bounds in world space */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Side Scrolling Camera", meta=(ClampMin=0, ClampMax=10000, Units="cm"))
	float CameraXMaxBounds = 10000.0f;

protected:

	/** Last cached camera vertical location. The camera only adjusts its height if necessary. */
	float CurrentZ = 0.0f;

	/** First-time update camera setup flag */
	bool bSetup = true;
};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingCharacter.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingCharacter.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/CapsuleComponent.h"
#include "Camera/CameraComponent.h"
#include "Components/InputComponent.h"
#include "InputActionValue.h"
#include "EnhancedInputComponent.h"
#include "InputAction.h"
#include "Engine/World.h"
#include "SideScrollingInteractable.h"
#include "Kismet/KismetMathLibrary.h"
#include "TimerManager.h"

ASideScrollingCharacter::ASideScrollingCharacter()
{
	PrimaryActorTick.bCanEverTick = true;

	// create the camera component
	Camera = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));
	Camera->SetupAttachment(RootComponent);

	Camera->SetRelativeLocationAndRotation(FVector(0.0f, 300.0f, 0.0f), FRotator(0.0f, -90.0f, 0.0f));

	// configure the collision capsule
	GetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);

	// configure the Pawn properties
	bUseControllerRotationYaw = false;

	// configure the character movement component
	GetCharacterMovement()->GravityScale = 1.75f;
	GetCharacterMovement()->MaxAcceleration = 1500.0f;
	GetCharacterMovement()->BrakingFrictionFactor = 1.0f;
	GetCharacterMovement()->bUseSeparateBrakingFriction = true;
	GetCharacterMovement()->Mass = 500.0f;

	GetCharacterMovement()->SetWalkableFloorAngle(75.0f);
	GetCharacterMovement()->MaxWalkSpeed = 500.0f;
	GetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2000.0f;
	GetCharacterMovement()->bIgnoreBaseRotation = true;

	GetCharacterMovement()->PerchRadiusThreshold = 15.0f;
	GetCharacterMovement()->LedgeCheckThreshold = 6.0f;

	GetCharacterMovement()->JumpZVelocity = 750.0f;
	GetCharacterMovement()->AirControl = 1.0f;

	GetCharacterMovement()->RotationRate = FRotator(0.0f, 750.0f, 0.0f);
	GetCharacterMovement()->bOrientRotationToMovement = true;

	GetCharacterMovement()->SetPlaneConstraintNormal(FVector(0.0f, 1.0f, 0.0f));
	GetCharacterMovement()->bConstrainToPlane = true;

	// enable double jump
	JumpMaxCount = 2;
}

void ASideScrollingCharacter::EndPlay(EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the wall jump timer
	GetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);
}

void ASideScrollingCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Set up action bindings
	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
	{
		// Jumping
		EnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ASideScrollingCharacter::DoJumpStart);
		EnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DoJumpEnd);

		// Interacting
		EnhancedInputComponent->BindAction(InteractAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::DoInteract);

		// Moving
		EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Move);

		// Dropping from platform
		EnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Drop);
		EnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DropReleased);

	}
}

void ASideScrollingCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)
{
	Super::NotifyHit(MyComp, Other, OtherComp, bSelfMoved, HitLocation, HitNormal, NormalImpulse, Hit);

	// only apply push impulse if we're falling
	if (!GetCharacterMovement()->IsFalling())
	{
		return;
	}

	// ensure the colliding component is valid
	if (OtherComp)
	{
		// ensure the component is movable and simulating physics
		if (OtherComp->Mobility == EComponentMobility::Movable && OtherComp->IsSimulatingPhysics())
		{
			const FVector PushDir = FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f);

			// push the component away
			OtherComp->AddImpulse(PushDir * JumpPushImpulse, NAME_None, true);
		}
	}
}

void ASideScrollingCharacter::Landed(const FHitResult& Hit)
{
	// reset the double jump
	bHasDoubleJumped = false;
}

void ASideScrollingCharacter::Move(const FInputActionValue& Value)
{
	FVector2D MoveVector = Value.Get<FVector2D>();

	// route the input
	DoMove(MoveVector.Y);
}

void ASideScrollingCharacter::Drop(const FInputActionValue& Value)
{
	// route the input
	DoDrop(Value.Get<float>());
}

void ASideScrollingCharacter::DropReleased(const FInputActionValue& Value)
{
	// reset the input
	DoDrop(0.0f);
}

void ASideScrollingCharacter::DoMove(float Forward)
{
	// is movement temporarily disabled after wall jumping?
	if (!bHasWallJumped)
	{
		// save the movement values
		ActionValueY = Forward;

		// figure out the movement direction
		const FVector MoveDir = FVector(1.0f, Forward > 0.0f ? 0.1f : -0.1f, 0.0f);

		// apply the movement input
		AddMovementInput(MoveDir, Forward);
	}
}

void ASideScrollingCharacter::DoDrop(float Value)
{
	// save the movement value
	DropValue = Value;
}

void ASideScrollingCharacter::DoJumpStart()
{
	// handle advanced jump behaviors
	MultiJump();
}

void ASideScrollingCharacter::DoJumpEnd()
{
	StopJumping();
}

void ASideScrollingCharacter::DoInteract()
{
	// do a sphere trace to look for interactive objects
	FHitResult OutHit;

	const FVector Start = GetActorLocation();
	const FVector End = Start + FVector(100.0f, 0.0f, 0.0f);

	FCollisionShape ColSphere;
	ColSphere.SetSphere(InteractionRadius);

	FCollisionObjectQueryParams ObjectParams;
	ObjectParams.AddObjectTypesToQuery(ECC_Pawn);
	ObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);

	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(this);

	if (GetWorld()->SweepSingleByObjectType(OutHit, Start, End, FQuat::Identity, ObjectParams, ColSphere, QueryParams))
	{
		// have we hit an interactable?
		if (ISideScrollingInteractable* Interactable = Cast<ISideScrollingInteractable>(OutHit.GetActor()))
		{
			// interact
			Interactable->Interaction(this);
		}
	}
}

void ASideScrollingCharacter::MultiJump()
{
	// does the user want to drop to a lower platform?
	if (DropValue > 0.0f)
	{
		CheckForSoftCollision();
		return;
	}

	// reset the drop value
	DropValue = 0.0f;

	// if we're grounded, disregard advanced jump logic
	if (!GetCharacterMovement()->IsFalling())
	{
		Jump();
		return;
	}

	// if we have a horizontal input, try for wall jump first
	if (!bHasWallJumped && !FMath::IsNearlyZero(ActionValueY))
	{
		// trace ahead of the character for walls
		FHitResult OutHit;

		const FVector Start = GetActorLocation();
		const FVector End = Start + (FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f) * WallJumpTraceDistance);

		FCollisionQueryParams QueryParams;
		QueryParams.AddIgnoredActor(this);

		GetWorld()->LineTraceSingleByChannel(OutHit, Start, End, ECC_Visibility, QueryParams);

		if (OutHit.bBlockingHit)
		{
			// rotate to the bounce direction
			const FRotator BounceRot = UKismetMathLibrary::MakeRotFromX(OutHit.ImpactNormal);
			SetActorRotation(FRotator(0.0f, BounceRot.Yaw, 0.0f));

			// calculate the impulse vector
			FVector WallJumpImpulse = OutHit.ImpactNormal * WallJumpHorizontalImpulse;
			WallJumpImpulse.Z = GetCharacterMovement()->JumpZVelocity * WallJumpVerticalMultiplier;

			// launch the character away from the wall
			LaunchCharacter(WallJumpImpulse, true, true);

			// enable wall jump lockout for a bit
			bHasWallJumped = true;

			// schedule wall jump lockout reset
			GetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &ASideScrollingCharacter::ResetWallJump, DelayBetweenWallJumps, false);

			return;
		}
	}

	// test for double jump only if we haven't already tested for wall jump
	if (!bHasWallJumped)
	{
		// The movement component handles double jump but we still need to manage the flag for animation
		if (!bHasDoubleJumped)
		{
			// raise the double jump flag
			bHasDoubleJumped = true;

			// let the CMC handle jump
			Jump();
		}
	}
}

void ASideScrollingCharacter::CheckForSoftCollision()
{
	// reset the drop value
	DropValue = 0.0f;

	// trace down 
	FHitResult OutHit;

	const FVector Start = GetActorLocation();
	const FVector End = Start + (FVector::DownVector * SoftCollisionTraceDistance);

	FCollisionObjectQueryParams ObjectParams;
	ObjectParams.AddObjectTypesToQuery(SoftCollisionObjectType);

	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(this);

	GetWorld()->LineTraceSingleByObjectType(OutHit, Start, End, ObjectParams, QueryParams);

	// did we hit a soft floor?
	if (OutHit.GetActor())
	{
		// drop through the floor
		SetSoftCollision(true);
	}
}

void ASideScrollingCharacter::ResetWallJump()
{
	// reset the wall jump flag
	bHasWallJumped = false;
}

void ASideScrollingCharacter::SetSoftCollision(bool bEnabled)
{
	// enable or disable collision response to the soft collision channel
	GetCapsuleComponent()->SetCollisionResponseToChannel(SoftCollisionObjectType, bEnabled ? ECR_Ignore : ECR_Block);
}

bool ASideScrollingCharacter::HasDoubleJumped() const
{
	return bHasDoubleJumped;
}

bool ASideScrollingCharacter::HasWallJumped() const
{
	return bHasWallJumped;
}

================
File: ActionPractice\Variant_SideScrolling\SideScrollingCharacter.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "SideScrollingCharacter.generated.h"

class UCameraComponent;
class UInputAction;
struct FInputActionValue;

/**
 *  A player-controllable character side scrolling game
 */
UCLASS(abstract)
class ASideScrollingCharacter : public ACharacter
{
	GENERATED_BODY()

	/** Player camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Camera", meta = (AllowPrivateAccess = "true"))
	UCameraComponent* Camera;

protected:

	/** Move Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* MoveAction;

	/** Jump Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* JumpAction;

	/** Drop from Platform Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* DropAction;

	/** Interact Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Input")
	UInputAction* InteractAction;

	/** Max distance that interactive objects can be triggered */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float InteractionRadius = 200.0f;

	/** Time to disable input after a wall jump to preserve momentum */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float DelayBetweenWallJumps = 0.3f;

	/** Impulse to manually push physics objects while we're in midair */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float JumpPushImpulse = 600.0f;

	/** Distance to trace ahead of the character for wall jumps */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float WallJumpTraceDistance = 50.0f;

	/** Horizontal impulse to apply to the character during wall jumps */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float WallJumpHorizontalImpulse = 500.0f;

	/** Multiplies the jump Z velocity for wall jumps. */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float WallJumpVerticalMultiplier = 1.4f;

	/** Collision object type to use for soft collision traces (dropping down floors) */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	TEnumAsByte<ECollisionChannel> SoftCollisionObjectType;

	/** Distance to trace down during soft collision checks */
	UPROPERTY(EditAnywhere, Category="Side Scrolling")
	float SoftCollisionTraceDistance = 1000.0f;

	/** Wall jump lockout timer */
	FTimerHandle WallJumpTimer;

	/** Last captured horizontal movement input value */
	float ActionValueY = 0.0f;

	/** Last captured platform drop axis value */
	float DropValue = 0.0f;

	/** If true, this character has already wall jumped */
	bool bHasWallJumped = false;

	/** If true, this character has already double jumped */
	bool bHasDoubleJumped = false;

	/** If true, this character is moving along the side scrolling axis */
	bool bMovingHorizontally = false;

public:
	
	/** Constructor */
	ASideScrollingCharacter();

protected:

	/** Gameplay cleanup */
	virtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;

	/** Initialize input action bindings */
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	/** Collision handling */
	virtual void NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit) override;

	/** Landing handling */
	virtual void Landed(const FHitResult& Hit) override;

protected:

	/** Called for movement input */
	void Move(const FInputActionValue& Value);

	/** Called for drop from platform input */
	void Drop(const FInputActionValue& Value);

	/** Called for drop from platform input release */
	void DropReleased(const FInputActionValue& Value);

public:

	/** Handles move inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoMove(float Forward);

	/** Handles drop inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoDrop(float Value);

	/** Handles jump pressed inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoJumpStart();

	/** Handles jump pressed inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoJumpEnd();

	/** Handles interact inputs from either controls or UI interfaces */
	UFUNCTION(BlueprintCallable, Category="Input")
	virtual void DoInteract();

protected:

	/** Handles advanced jump logic */
	void MultiJump();

	/** Checks for soft collision with platforms */
	void CheckForSoftCollision();

	/** Resets wall jump lockout. Called from timer after a wall jump */
	void ResetWallJump();

public:

	/** Sets the soft collision response. True passes, False blocks */
	void SetSoftCollision(bool bEnabled);

public:

	/** Returns true if the character has just double jumped */
	UFUNCTION(BlueprintPure, Category="Side Scrolling")
	bool HasDoubleJumped() const;

	/** Returns true if the character has just wall jumped */
	UFUNCTION(BlueprintPure, Category="Side Scrolling")
	bool HasWallJumped() const;
};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingCPP.Build.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class SideScrollingCPP : ModuleRules
{
	public SideScrollingCPP(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] {
			"Core",
			"CoreUObject",
			"Engine",
			"InputCore",
			"EnhancedInput",
			"StateTreeModule",
			"GameplayStateTreeModule"
		});

		PrivateDependencyModuleNames.AddRange(new string[] {  });

		PublicIncludePaths.AddRange(new string[] {
			"SideScrollingCPP",
			"SideScrollingCPP/NPC",
			"SideScrollingCPP/Gameplay"
		});
	}
}

================
File: ActionPractice\Variant_SideScrolling\SideScrollingGameMode.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingGameMode.h"
#include "Kismet/GameplayStatics.h"
#include "Blueprint/UserWidget.h"
#include "SideScrollingUI.h"
#include "SideScrollingPickup.h"

void ASideScrollingGameMode::BeginPlay()
{
	Super::BeginPlay();

	// create the game UI
	APlayerController* OwningPlayer = UGameplayStatics::GetPlayerController(GetWorld(), 0);
	
	UserInterface = CreateWidget<USideScrollingUI>(OwningPlayer, UserInterfaceClass);

	check(UserInterface);
}

void ASideScrollingGameMode::ProcessPickup()
{
	// increment the pickups counter
	++PickupsCollected;

	// if this is the first pickup we collect, show the UI
	if (PickupsCollected == 1)
	{
		UserInterface->AddToViewport(0);
	}

	// update the pickups counter on the UI
	UserInterface->UpdatePickups(PickupsCollected);
}

================
File: ActionPractice\Variant_SideScrolling\SideScrollingGameMode.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "SideScrollingGameMode.generated.h"

class USideScrollingUI;

/**
 *  Simple Side Scrolling Game Mode
 *  Spawns and manages the game UI
 *  Counts pickups collected by the player
 */
UCLASS(abstract)
class ASideScrollingGameMode : public AGameModeBase
{
	GENERATED_BODY()
	
protected:

	/** Class of UI widget to spawn when the game starts */
	UPROPERTY(EditAnywhere, Category="UI")
	TSubclassOf<USideScrollingUI> UserInterfaceClass;

	/** User interface widget for the game */
	UPROPERTY(BlueprintReadOnly, Category="UI")
	TObjectPtr<USideScrollingUI> UserInterface;

	/** Number of pickups collected by the player */
	UPROPERTY(BlueprintReadOnly, Category="Picups")
	int32 PickupsCollected = 0;

protected:

	/** Initialization */
	virtual void BeginPlay() override;

public:

	/** Receives an interaction event from another actor */
	virtual void ProcessPickup();
};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingInteractable.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingInteractable.h"

// Add default functionality here for any IInteractable functions that are not pure virtual.

================
File: ActionPractice\Variant_SideScrolling\SideScrollingInteractable.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "SideScrollingInteractable.generated.h"

/**
 *  
 */
UINTERFACE(MinimalAPI, NotBlueprintable)
class USideScrollingInteractable : public UInterface
{
	GENERATED_BODY()
};

/**
 *  Simple interface to allow Actors to interact without having knowledge of their internal implementation.
 */
class ISideScrollingInteractable
{
	GENERATED_BODY()

public:

	/** Triggers an interaction by the provided Actor */
	UFUNCTION(BlueprintCallable, Category="Interactable")
	virtual void Interaction(AActor* Interactor) = 0;

};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingPlayerController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingPlayerController.h"
#include "EnhancedInputSubsystems.h"
#include "InputMappingContext.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/PlayerStart.h"
#include "SideScrollingCharacter.h"
#include "Engine/LocalPlayer.h"
#include "Engine/World.h"

void ASideScrollingPlayerController::SetupInputComponent()
{
	// add the input mapping context
	if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))
	{
		for (UInputMappingContext* CurrentContext : DefaultMappingContexts)
		{
			Subsystem->AddMappingContext(CurrentContext, 0);
		}
	}
}

void ASideScrollingPlayerController::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);

	// subscribe to the pawn's OnDestroyed delegate
	InPawn->OnDestroyed.AddDynamic(this, &ASideScrollingPlayerController::OnPawnDestroyed);
}

void ASideScrollingPlayerController::OnPawnDestroyed(AActor* DestroyedActor)
{
	// find the player start
	TArray<AActor*> ActorList;
	UGameplayStatics::GetAllActorsOfClass(GetWorld(), APlayerStart::StaticClass(), ActorList);

	if (ActorList.Num() > 0)
	{
		// spawn a character at the player start
		const FTransform SpawnTransform = ActorList[0]->GetActorTransform();

		if (ASideScrollingCharacter* RespawnedCharacter = GetWorld()->SpawnActor<ASideScrollingCharacter>(CharacterClass, SpawnTransform))
		{
			// possess the character
			Possess(RespawnedCharacter);
		}
	}
}

================
File: ActionPractice\Variant_SideScrolling\SideScrollingPlayerController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "EnhancedInput/Public/InputAction.h"
#include "SideScrollingPlayerController.generated.h"

class ASideScrollingCharacter;
class UInputMappingContext;

/**
 *  A simple Side Scrolling Player Controller
 *  Manages input mappings
 *  Respawns the player pawn at the player start if it is destroyed
 */
UCLASS(abstract)
class ASideScrollingPlayerController : public APlayerController
{
	GENERATED_BODY()
	
protected:

	/** Input mapping context for this player */
	UPROPERTY(EditAnywhere, Category="Input")
	TArray<UInputMappingContext*> DefaultMappingContexts;

	/** Character class to respawn when the possessed pawn is destroyed */
	UPROPERTY(EditAnywhere, Category="Respawn")
	TSubclassOf<ASideScrollingCharacter> CharacterClass;

protected:

	/** Initialize input bindings */
	virtual void SetupInputComponent() override;

	/** Pawn initialization */
	virtual void OnPossess(APawn* InPawn) override;

	/** Called if the possessed pawn is destroyed */
	UFUNCTION()
	void OnPawnDestroyed(AActor* DestroyedActor);

};

================
File: ActionPractice\Variant_SideScrolling\SideScrollingUI.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingUI.h"

================
File: ActionPractice\Variant_SideScrolling\SideScrollingUI.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "SideScrollingUI.generated.h"

/**
 *  Simple Side Scrolling game UI
 *  Displays and manages a pickup counter
 */
UCLASS(abstract)
class USideScrollingUI : public UUserWidget
{
	GENERATED_BODY()
	
public:

	/** Update the widget's pickup counter */
	UFUNCTION(BlueprintImplementableEvent, Category="UI")
	void UpdatePickups(int32 Amount);
};

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingAIController.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingAIController.h"
#include "GameplayStateTreeModule/Public/Components/StateTreeAIComponent.h"

ASideScrollingAIController::ASideScrollingAIController()
{
	// create the StateTree AI Component
	StateTreeAI = CreateDefaultSubobject<UStateTreeAIComponent>(TEXT("StateTreeAI"));
	check(StateTreeAI);

	// ensure we start the StateTree when we possess the pawn
	bStartAILogicOnPossess = true;

	// ensure we're attached to the possessed character.
	// this is necessary for EnvQueries to work correctly
	bAttachToPawn = true;
}

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingAIController.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "AIController.h"
#include "SideScrollingAIController.generated.h"

class UStateTreeAIComponent;

/**
 *  A basic AI Controller capable of running StateTree
 */
UCLASS(abstract)
class ASideScrollingAIController : public AAIController
{
	GENERATED_BODY()
	
	/** StateTree Component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "AI", meta = (AllowPrivateAccess = "true"))
	UStateTreeAIComponent* StateTreeAI;

public:

	/** Constructor */
	ASideScrollingAIController();
};

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingNPC.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingNPC.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "TimerManager.h"

ASideScrollingNPC::ASideScrollingNPC()
{
 	PrimaryActorTick.bCanEverTick = true;

	GetCharacterMovement()->MaxWalkSpeed = 150.0f;
}

void ASideScrollingNPC::EndPlay(EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// clear the deactivation timer
	GetWorld()->GetTimerManager().ClearTimer(DeactivationTimer);
}

void ASideScrollingNPC::Interaction(AActor* Interactor)
{
	// ignore if this NPC has already been deactivated
	if (bDeactivated)
	{
		return;
	}

	// reset the deactivation flag
	bDeactivated = true;

	// stop character movement immediately
	GetCharacterMovement()->StopMovementImmediately();

	// launch the NPC away from the interactor
	FVector LaunchVector = Interactor->GetActorForwardVector() * LaunchImpulse;
	LaunchVector.Y = 0.0f;
	LaunchVector.Z = LaunchVerticalImpulse;

	LaunchCharacter(LaunchVector, true, true);

	// set up a timer to schedule reactivation
	GetWorld()->GetTimerManager().SetTimer(DeactivationTimer, this, &ASideScrollingNPC::ResetDeactivation, DeactivationTime, false);
}

void ASideScrollingNPC::ResetDeactivation()
{
	// reset the deactivation flag
	bDeactivated = false;
}

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingNPC.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "SideScrollingInteractable.h"
#include "SideScrollingNPC.generated.h"

/**
 *  Simple platforming NPC
 *  Its behaviors will be dictated by a possessing AI Controller
 *  It can be temporarily deactivated through Actor interactions
 */
UCLASS(abstract)
class ASideScrollingNPC : public ACharacter, public ISideScrollingInteractable
{
	GENERATED_BODY()

protected:

	/** Horizontal impulse to apply to the NPC when it's interacted with */
	UPROPERTY(EditAnywhere, Category="NPC", meta=(ClampMin=0, Units="cm/s"))
	float LaunchImpulse = 500.0f;

	/** Vertical impulse to apply to the NPC when it's interacted with */
	UPROPERTY(EditAnywhere, Category="NPC", meta=(ClampMin=0, Units="cm/s"))
	float LaunchVerticalImpulse = 500.0f;

	/** Time that the NPC remains deactivated after being interacted with */
	UPROPERTY(EditAnywhere, Category="NPC", meta=(ClampMin=0, Units="s"))
	float DeactivationTime = 3.0f;

public:

	/** If true, this NPC is deactivated and will not be interacted with */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="NPC")
	bool bDeactivated = false;

	/** Timer to reactivate the NPC */
	FTimerHandle DeactivationTimer;

public:

	/** Constructor */
	ASideScrollingNPC();

public:

	/** Cleanup */
	virtual void EndPlay(EEndPlayReason::Type EndPlayReason) override;

public:

//	~begin IInteractable interface 

	/** Performs an interaction triggered by another actor */
	virtual void Interaction(AActor* Interactor) override;

//	~end IInteractable interface

	/** Reactivates the NPC */
	void ResetDeactivation();
};

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingStateTreeUtility.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingStateTreeUtility.h"
#include "StateTreeExecutionContext.h"
#include "StateTreeExecutionTypes.h"
#include "AIController.h"
#include "Kismet/GameplayStatics.h"

EStateTreeRunStatus FStateTreeGetPlayerTask::Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const
{
	// get the instance data
	FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

	// set the player pawn as the target
	InstanceData.TargetPlayer = UGameplayStatics::GetPlayerPawn(InstanceData.Controller.Get(), 0);

	// are the NPC and target valid?
	if (IsValid(InstanceData.TargetPlayer) && IsValid(InstanceData.NPC))
	{
		InstanceData.bValidTarget = FVector::Distance(InstanceData.NPC->GetActorLocation(), InstanceData.TargetPlayer->GetActorLocation()) < InstanceData.RangeMax;
	}

	return EStateTreeRunStatus::Running;
}

#if WITH_EDITOR
FText FStateTreeGetPlayerTask::GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting /*= EStateTreeNodeFormatting::Text*/) const
{
	return FText::FromString("<b>Get Player</b>");
}
#endif // WITH_EDITOR

================
File: ActionPractice\Variant_SideScrolling\AI\SideScrollingStateTreeUtility.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "StateTreeTaskBase.h"

#include "SideScrollingStateTreeUtility.generated.h"

class AAIController;

/**
 *  Instance data for the FStateTreeGetPlayerTask task
 */
USTRUCT()
struct FStateTreeGetPlayerInstanceData
{
	GENERATED_BODY()

	/** NPC owning this task */
	UPROPERTY(VisibleAnywhere, Category = Context)
	TObjectPtr<APawn> NPC;

	/** Holds the found player pawn */
	UPROPERTY(VisibleAnywhere, Category = Context)
	TObjectPtr<AAIController> Controller;

	/** Holds the found player pawn */
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<APawn> TargetPlayer;

	/** Is the pawn close enough to be considered a valid target? */
	UPROPERTY(VisibleAnywhere)
	bool bValidTarget = false;

	/** Max distance to be considered a valid target */
	UPROPERTY(EditAnywhere, Category = Parameter, meta=(ClampMin = 0, Units = "cm"))
	float RangeMax = 1000.0f;
};

/**
 *  StateTree task to get the player-controlled character
 */
USTRUCT(meta=(DisplayName="Get Player", Category="Side Scrolling"))
struct FStateTreeGetPlayerTask : public FStateTreeTaskCommonBase
{
	GENERATED_BODY()

	/* Ensure we're using the correct instance data struct */
	using FInstanceDataType = FStateTreeGetPlayerInstanceData;
	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }

	/** Runs while the owning state is active */
	virtual EStateTreeRunStatus Tick(FStateTreeExecutionContext& Context, const float DeltaTime) const override;

#if WITH_EDITOR
	virtual FText GetDescription(const FGuid& ID, FStateTreeDataView InstanceDataView, const IStateTreeBindingLookup& BindingLookup, EStateTreeNodeFormatting Formatting = EStateTreeNodeFormatting::Text) const override;
#endif // WITH_EDITOR
};

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingJumpPad.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingJumpPad.h"
#include "Components/BoxComponent.h"
#include "GameFramework/Character.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/SceneComponent.h"

ASideScrollingJumpPad::ASideScrollingJumpPad()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the root comp
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));

	// create the bounding box
	Box = CreateDefaultSubobject<UBoxComponent>(TEXT("Box"));
	Box->SetupAttachment(RootComponent);

	// configure the bounding box
	Box->SetBoxExtent(FVector(115.0f, 90.0f, 20.0f), false);
	Box->SetRelativeLocation(FVector(0.0f, 0.0f, 16.0f));

	Box->SetCollisionObjectType(ECC_WorldDynamic);
	Box->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	Box->SetCollisionResponseToAllChannels(ECR_Ignore);
	Box->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);

	// add the overlap handler
	OnActorBeginOverlap.AddDynamic(this, &ASideScrollingJumpPad::BeginOverlap);
}

void ASideScrollingJumpPad::BeginOverlap(AActor* OverlappedActor, AActor* OtherActor)
{
	// were we overlapped by a character?
	if (ACharacter* OverlappingCharacter = Cast<ACharacter>(OtherActor))
	{
		// force the character to jump
		OverlappingCharacter->Jump();

		// launch the character to override its vertical velocity
		FVector LaunchVelocity = FVector::UpVector * ZStrength;
		OverlappingCharacter->LaunchCharacter(LaunchVelocity, false, true);
	}
}

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingJumpPad.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SideScrollingJumpPad.generated.h"

class UBoxComponent;

/**
 *  A simple jump pad that launches characters into the air
 */
UCLASS(abstract)
class ASideScrollingJumpPad : public AActor
{
	GENERATED_BODY()
	
	/** Jump pad bounding box */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Components", meta = (AllowPrivateAccess = "true"))
	UBoxComponent* Box;

protected:

	/** Vertical velocity to set the character to when they use the jump pad*/
	UPROPERTY(EditAnywhere, Category="Jump Pad", meta=(ClampMin=0, ClampMax=10000, Units="cm/s"))
	float ZStrength = 1000.0f;

public:	

	/** Constructor */
	ASideScrollingJumpPad();

protected:

	UFUNCTION()
	void BeginOverlap(AActor* OverlappedActor, AActor* OtherActor);

};

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingMovingPlatform.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingMovingPlatform.h"
#include "Components/SceneComponent.h"

ASideScrollingMovingPlatform::ASideScrollingMovingPlatform()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the root comp
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
}

void ASideScrollingMovingPlatform::Interaction(AActor* Interactor)
{
	// ignore interactions if we're already moving
	if (bMoving)
	{
		return;
	}

	// raise the movement flag
	bMoving = true;

	// pass control to BP for the actual movement
	BP_MoveToTarget();
}

void ASideScrollingMovingPlatform::ResetInteraction()
{
	// ignore if this is a one-shot platform
	if (bOneShot)
	{
		return;
	}

	// reset the movement flag
	bMoving = false;
}

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingMovingPlatform.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SideScrollingInteractable.h"
#include "SideScrollingMovingPlatform.generated.h"

/**
 *  Simple moving platform that can be triggered through interactions by other actors.
 *  The actual movement is performed by Blueprint code through latent execution nodes.
 */
UCLASS(abstract)
class ASideScrollingMovingPlatform : public AActor, public ISideScrollingInteractable
{
	GENERATED_BODY()
	
public:	
	
	/** Constructor */
	ASideScrollingMovingPlatform();

protected:

	/** If this is true, the platform is mid-movement and will ignore further interactions */
	bool bMoving = false;

	/** Destination of the platform in world space */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Moving Platform")
	FVector PlatformTarget;

	/** Time for the platform to move to the destination */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Moving Platform", meta=(ClampMin=0, Units="s"))
	float MoveDuration = 5.0f;

	/** If this is true, the platform will only move once. */
	UPROPERTY(EditAnywhere, Category="Moving Platform")
	bool bOneShot = false;

public:

// ~begin IInteractable interface 

	/** Performs an interaction triggered by another actor */
	virtual void Interaction(AActor* Interactor) override;

// ~end IInteractable interface

	/** Resets the interaction state. Must be called from BP code to reset the platform */
	UFUNCTION(BlueprintCallable, Category="Moving Platform")
	virtual void ResetInteraction();

protected:

	/** Allows Blueprint code to do the actual platform movement */
	UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, Category="Moving Platform", meta=(DisplayName="Move to Target"))
	void BP_MoveToTarget();

};

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingPickup.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingPickup.h"
#include "GameFramework/Character.h"
#include "SideScrollingGameMode.h"
#include "Components/SphereComponent.h"
#include "Components/SceneComponent.h"
#include "Engine/World.h"

ASideScrollingPickup::ASideScrollingPickup()
{
	PrimaryActorTick.bCanEverTick = false;

	// create the root comp
	RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));

	// create the bounding sphere
	Sphere = CreateDefaultSubobject<USphereComponent>(TEXT("Collision"));
	Sphere->SetupAttachment(RootComponent);

	Sphere->SetSphereRadius(100.0f);

	Sphere->SetCollisionObjectType(ECC_WorldDynamic);
	Sphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	Sphere->SetCollisionResponseToAllChannels(ECR_Ignore);
	Sphere->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);

	// add the overlap handler
	OnActorBeginOverlap.AddDynamic(this, &ASideScrollingPickup::BeginOverlap);
}

void ASideScrollingPickup::BeginOverlap(AActor* OverlappedActor, AActor* OtherActor)
{
	// have we collided against a character?
	if (ACharacter* OverlappedCharacter = Cast<ACharacter>(OtherActor))
	{
		// is this the player character?
		if (OverlappedCharacter->IsPlayerControlled())
		{
			// get the game mode
			if (ASideScrollingGameMode* GM = Cast<ASideScrollingGameMode>(GetWorld()->GetAuthGameMode()))
			{
				// tell the game mode to process a pickup
				GM->ProcessPickup();

				// disable collision so we don't get picked up again
				SetActorEnableCollision(false);

				// Call the BP handler. It will be responsible for destroying the pickup
				BP_OnPickedUp();
			}
		}
	}
}

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingPickup.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SideScrollingPickup.generated.h"

class USphereComponent;

/**
 *  A simple side scrolling game pickup
 *  Increments a counter on the GameMode
 */
UCLASS(abstract)
class ASideScrollingPickup : public AActor
{
	GENERATED_BODY()
	
	/** Pickup bounding sphere */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Components", meta = (AllowPrivateAccess = "true"))
	USphereComponent* Sphere;

public:

	/** Constructor */
	ASideScrollingPickup();

protected:

	/** Handles pickup collision */
	UFUNCTION()
	void BeginOverlap(AActor* OverlappedActor, AActor* OtherActor);

	/** Passes control to BP to play effects on pickup */
	UFUNCTION(BlueprintImplementableEvent, Category="Pickup", meta=(DisplayName = "On Picked Up"))
	void BP_OnPickedUp();
};

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingSoftPlatform.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.


#include "SideScrollingSoftPlatform.h"
#include "Components/SceneComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Components/BoxComponent.h"
#include "SideScrollingCharacter.h"

ASideScrollingSoftPlatform::ASideScrollingSoftPlatform()
{
 	PrimaryActorTick.bCanEverTick = true;

	// create the root component
	RootComponent = Root = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));

	// create the mesh
	Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
	Mesh->SetupAttachment(Root);

	Mesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	Mesh->SetCollisionObjectType(ECC_WorldStatic);
	Mesh->SetCollisionResponseToAllChannels(ECR_Block);

	// create the collision check box
	CollisionCheckBox = CreateDefaultSubobject<UBoxComponent>(TEXT("Collision Check Box"));
	CollisionCheckBox->SetupAttachment(Mesh);

	CollisionCheckBox->SetRelativeLocation(FVector(0.0f, 0.0f, -40.0f));
	CollisionCheckBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	CollisionCheckBox->SetCollisionObjectType(ECC_WorldDynamic);
	CollisionCheckBox->SetCollisionResponseToAllChannels(ECR_Ignore);
	CollisionCheckBox->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);

	// subscribe to the overlap events
	CollisionCheckBox->OnComponentBeginOverlap.AddDynamic(this, &ASideScrollingSoftPlatform::OnSoftCollisionOverlap);
}

void ASideScrollingSoftPlatform::OnSoftCollisionOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// have we overlapped a character?
	if (ASideScrollingCharacter* Char = Cast<ASideScrollingCharacter>(OtherActor))
	{
		// disable the soft collision channel
		Char->SetSoftCollision(true);
	}
}

void ASideScrollingSoftPlatform::NotifyActorEndOverlap(AActor* OtherActor)
{
	Super::NotifyActorEndOverlap(OtherActor);

	// have we overlapped a character?
	if (ASideScrollingCharacter* Char = Cast<ASideScrollingCharacter>(OtherActor))
	{
		// enable the soft collision channel
		Char->SetSoftCollision(false);
	}
}

================
File: ActionPractice\Variant_SideScrolling\Gameplay\SideScrollingSoftPlatform.h
================
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SideScrollingSoftPlatform.generated.h"

class USceneComponent;
class UStaticMeshComponent;
class UBoxComponent;

/**
 *  A side scrolling game platform that the character can jump or drop through.
 */
UCLASS(abstract)
class ASideScrollingSoftPlatform : public AActor
{
	GENERATED_BODY()
	
	/** Root component */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Components", meta = (AllowPrivateAccess = "true"))
	USceneComponent* Root;

	/** Platform mesh. The part we collide against and see */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Components", meta = (AllowPrivateAccess = "true"))
	UStaticMeshComponent* Mesh;

	/** Collision volume that toggles soft collision on the character when they're below the platform. */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category ="Components", meta = (AllowPrivateAccess = "true"))
	UBoxComponent* CollisionCheckBox;

public:	
	
	/** Constructor */
	ASideScrollingSoftPlatform();

protected:

	/** Handles soft collision check box overlaps */
	UFUNCTION()
	void OnSoftCollisionOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

	/** Restores soft collision state when overlap ends */
	virtual void NotifyActorEndOverlap(AActor* OtherActor) override;
};
